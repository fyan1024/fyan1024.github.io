{"/docs/coding/bash/":{"data":{"":"","cli#CLI":"\rbash exit pwd cat /etc/shells","变量#变量":"Bash 变量简介\rBash 中的变量分为两类：环境变量 和 自定义变量。\n环境变量\r环境变量是由系统定义并预先配置的变量，进入 Shell 时已经存在，可以直接使用。环境变量通常由父 Shell 传递给子 Shell，或系统启动时自动配置。\n使用 env 或 printenv 命令可以查看所有环境变量：\n$ env # 或者 $ printenv\r常见的环境变量\rBASHPID：当前 Bash 进程的 ID。 BASHOPTS：当前 Shell 的参数（可用 shopt 修改）。 DISPLAY：图形界面的显示器名，通常为 :0，表示 X Server 的第一个显示器。 EDITOR：默认文本编辑器。 HOME：用户主目录。 HOST：当前主机名。 IFS：词与词之间的分隔符，默认为空格。 LANG：字符集和语言编码，如 zh_CN.UTF-8。 PATH：用于搜索可执行程序的目录列表。 PS1：Shell 提示符。 PS2：多行输入时的次级提示符。 PWD：当前工作目录。 RANDOM：返回一个 0 到 32767 之间的随机数。 SHELL：当前 Shell 的名字。 TERM：终端类型。 UID：当前用户的 ID。 USER：当前用户名。 许多环境变量是只读的，像常量一样，变量名通常使用全大写。例如，用户定义的常量也可以使用全大写字母来命名。\n注意：Bash 变量名是区分大小写的，例如 HOME 和 home 是不同的变量。\n查看环境变量\r使用 printenv 或 echo 命令查看单个环境变量的值：\n$ printenv PATH # 或者 $ echo $PATH\r注意：使用 printenv 命令时，变量名前不需要 $ 符号。\n自定义变量\r自定义变量是用户在当前 Shell 会话中定义的变量。它们只在当前 Shell 中有效，退出 Shell 后，变量就消失了。\n可以使用 set 命令查看所有变量（包括环境变量和自定义变量），以及所有 Bash 函数：\n$ set\r通过这些工具，用户可以轻松管理和查看 Shell 中的变量和函数。\n创建变量\r在 Bash 中，用户可以根据以下规则创建自定义变量：\n变量名规则\r变量名只能由字母、数字和下划线字符组成。 第一个字符必须是字母或下划线，不能是数字。 变量名中不能包含空格或标点符号。 声明变量的语法\rvariable=value\r在这个语法中，等号左边是变量名，右边是变量的值。注意：等号两边不能有空格。\n包含空格的变量值\r如果变量的值包含空格，则必须使用引号将值括起来：\nmyvar=\"hello world\"\rBash 中变量的特点\rBash 没有数据类型的概念，所有变量的值都是字符串。 变量的值可以是字符串、其他变量的值、命令的执行结果，或者数学运算的结果。 示例\ra=z # 变量 a 的值是字符串 \"z\" b=\"a string\" # 值包含空格时，用引号括起来 c=\"a string and $b\" # 变量可以引用其他变量的值 d=\"\\t\\ta string\\n\" # 使用转义字符表示特殊字符 e=$(ls -l foo.txt) # 变量值可以是命令执行结果 f=$((5 * 7)) # 变量值可以是数学运算的结果\r变量的重新赋值\r变量可以被重新赋值，后面的赋值会覆盖之前的值：\n$ foo=1 $ foo=2 $ echo $foo 2\r在这个例子中，第二次给 foo 赋值覆盖了第一次的赋值。\n同一行定义多个变量\r可以在同一行中定义多个变量，使用分号 ; 分隔：\n$ foo=1; bar=2\r这个例子中，foo 和 bar 在同一行中被定义为两个不同的变量。\n通过遵循这些规则，您可以在 Bash 中灵活地创建和管理变量。\n读取变量\r在 Bash 中，读取变量的方式是通过在变量名前加上美元符号 $，让 Bash 将其解析为变量的值。\n基本读取方式\r$ foo=bar $ echo $foo bar\r在这个例子中，变量 foo 的值是 bar，通过 $foo 读取并输出。\n变量不存在时\r如果读取的变量不存在，Bash 不会报错，而是返回空字符：\n$ echo $nonexistent\r输出为空，nonexistent 是不存在的变量。\n使用美元符号 $\r由于 $ 是 Bash 的特殊字符，如果需要将其当作普通美元符号使用，需要进行转义。例如：\n$ echo The total is $100.00 The total is 00.00\r在这个例子中，$100 中的 $1 被解释为变量，但由于变量 1 没有定义，所以结果为 00.00。正确的写法是：\n$ echo The total is \\$100.00 The total is $100.00\r使用花括号读取变量\r变量名可以使用花括号 {} 包围，特别是在变量名与其他字符连用时，花括号能帮助 Bash 正确解析变量。\n示例\r$ a=foo $ echo $a_file # 无输出 $ echo ${a}_file foo_file\r在第一个例子中，$a_file 被当作一个整体变量名，导致 Bash 无法识别这个变量。而使用 ${a}_file 则正确读取了变量 a 的值，并与后面的 _file 连接。\n事实上，$foo 可以看作是 ${foo} 的简写形式。\n读取变量的变量\r如果一个变量的值是另一个变量名，可以使用 ${!varname} 的语法来读取最终的变量值：\n$ myvar=USER $ echo ${!myvar} ruanyf\r在这个例子中，myvar 的值是 USER，${!myvar} 的写法将 USER 解析为变量并输出其值。\n保持变量中的空格\r如果变量的值包含连续空格或特殊字符，最好将变量放在双引号内读取，以保持原始格式：\n$ a=\"1 2 3\" $ echo $a 1 2 3 $ echo \"$a\" 1 2 3\r在没有双引号的情况下，Bash 会将连续的空格压缩为一个空格。使用双引号可以保持原始的格式和空格数量。\n通过这些方法，Bash 可以灵活地读取变量的值并正确处理特殊字符或空格。\n删除变量\r在 Bash 中，删除一个变量可以使用 unset 命令：\nunset NAME\r注意事项\runset 命令会删除指定的变量，但由于不存在的变量在 Bash 中默认等于空字符串，因此即使删除了变量，读取时返回的值依然是空字符串。 这使得 unset 命令的实际作用相对有限。 另一种删除变量的方法\r将变量设为空字符串也可以被视为“删除”变量：\n$ foo='' $ foo=\r这两种写法都将变量 foo 设置为空字符串，从而达到了删除变量的效果。\n由于不存在的变量默认为空字符串，因此通过这种方式删除变量通常比 unset 命令更为直接和常用。\n总结\r使用 unset NAME 删除变量。 或者，将变量设置为空字符串 foo='' 或 foo= 也可以达到同样的效果。 两者的区别在于，unset 完全删除了变量，而将变量设为空字符串则是清除了其值。\n输出变量，export 命令\r在 Bash 中，用户创建的变量只在当前 Shell 中有效，子 Shell 默认无法读取父 Shell 中定义的变量。要将变量传递给子 Shell，需要使用 export 命令，将变量标记为环境变量。\n基本用法\r先定义变量，再使用 export 命令：\nNAME=foo export NAME\r也可以在定义和输出时同时使用 export：\nexport NAME=value\r通过 export 命令，变量 $NAME 不仅可在当前 Shell 使用，也可以在任何新建的子 Shell 中读取。\n子 Shell 中的变量继承与修改\r子 Shell 可以继承父 Shell 中通过 export 输出的变量，但是对这些变量的修改不会影响父 Shell：\n# 在父 Shell 中输出变量 $ export foo=bar # 新建子 Shell $ bash # 读取继承的变量 $ echo $foo bar # 修改变量 $ foo=baz # 退出子 Shell $ exit # 回到父 Shell，查看变量 $ echo $foo bar\r在这个例子中，子 Shell 修改了变量 foo，但退出子 Shell 后，父 Shell 中的 foo 仍保持原值。\n特殊变量\rBash 提供了一些特殊变量，它们由 Shell 维护，用户无法直接修改。\n$?\n表示上一个命令的退出状态码。值为 0 表示成功，非零值表示失败。\n$ ls doesnotexist ls: doesnotexist: No such file or directory $ echo $? 1\r$$\n当前 Shell 的进程 ID（PID）。常用于临时文件命名：\n$ echo $$ 10662\r$_\n上一个命令的最后一个参数：\n$ grep dictionary /usr/share/dict/words dictionary $ echo $_ /usr/share/dict/words\r$!\n最近一个后台运行的进程 ID：\n$ firefox \u0026 [1] 11064 $ echo $! 11064\r$0\n当前 Shell 的名称，或者脚本名（如果在脚本中执行）：\n$ echo $0 bash\r$-\n当前 Shell 的启动参数：\n$ echo $- himBHs\r$@ 和 $#\n$#：脚本的参数数量。 $@：脚本的所有参数。 这些特殊变量在 Bash 中广泛使用，用于获取系统信息、控制流程、处理参数等场景。\n变量的默认值\rBash 提供了四个特殊语法，用于处理变量的默认值，以确保变量不为空。这些语法在没有定义或变量为空时提供默认值、赋值或处理错误信息。\n${varname:-word}\n如果变量 varname 存在且不为空，则返回它的值，否则返回 word。\n适用于为未定义变量提供默认值。\n$ echo ${count:-0} 0\r${varname:=word}\n如果变量 varname 存在且不为空，则返回它的值；否则将它设置为 word 并返回 word。\n用于设置变量的默认值。\n$ echo ${count:=0} 0\r${varname:+word}\n如果变量 varname 存在且不为空，则返回 word；否则返回空值。\n用于测试变量是否存在。\n$ echo ${count:+1} 1\r${varname:?message}\n如果变量 varname 存在且不为空，则返回它的值；否则打印 varname: message 并中断脚本执行。\n用于确保变量被定义。\n$ echo ${count:?\"undefined!\"} # 如果 count 未定义，脚本将打印错误信息并退出。\r示例：脚本参数\r变量名部分可以用脚本参数（如 $1、$2）代替，常用于处理脚本参数：\nfilename=${1:?\"filename missing.\"}\rdeclare 命令\rdeclare 命令用于声明特殊类型的变量或设置限制，例如声明只读变量或整数变量。它还可以用于查看变量信息。\n基本语法\rdeclare OPTION VARIABLE=value\r常用选项\r-a：声明数组变量。 -f：输出所有函数的定义。 -F：仅输出函数名，不输出函数定义。 -i：声明整数变量，允许进行数学运算。 -l：声明变量为小写字母。 -p：查看变量信息。 -r：声明只读变量，变量不能被修改或删除。 -u：声明变量为大写字母。 -x：将变量标记为环境变量（类似 export）。 选项示例\r-i：整数声明\n$ declare -i val1=12 val2=5 $ result=val1*val2 $ echo $result 60\r-x：输出为环境变量\n$ declare -x foo\r-r：只读变量\n$ declare -r bar=1 $ bar=2 bash: bar：只读变量\r-u：大写字母变量\n$ declare -u foo $ foo=upper $ echo $foo UPPER\r-l：小写字母变量\n$ declare -l bar $ bar=LOWER $ echo $bar lower\r-p：查看变量信息\n$ foo=hello $ declare -p foo declare -- foo=\"hello\"\r-f：输出所有函数\n$ declare -f\r-F：输出函数名\n$ declare -F\r通过这些工具和语法，Bash 提供了强大的变量控制和操作功能，允许用户灵活设置和管理变量的默认值、类型和范围。\nreadonly 命令\rreadonly 命令用于声明只读变量，一旦声明为只读，该变量的值不能被修改，也不能使用 unset 删除它。readonly 相当于 declare -r。\n基本用法\r$ readonly foo=1 $ foo=2 bash: foo：只读变量 $ echo $? 1\r在上面的例子中，尝试修改只读变量 foo 会导致错误，返回码为 1，表示命令执行失败。\n参数\r-f：声明只读函数。 -p：打印出所有只读变量。 -a：声明只读数组。 示例\r查看所有只读变量：\n$ readonly -p\r声明只读函数：\n$ readonly -f my_function\rlet 命令\rlet 命令用于声明变量时执行算术运算，允许直接在声明过程中进行计算。\n基本用法\r$ let foo=1+2 $ echo $foo 3\r在上面的例子中，let 命令计算了 1 + 2 并将结果赋值给变量 foo。\n带空格的表达式\r当表达式包含空格时，需要使用引号将表达式括起来：\n$ let \"foo = 1 + 2\"\r多变量赋值\rlet 支持同时对多个变量赋值，使用空格分隔表达式：\n$ let \"v1 = 1\" \"v2 = v1++\" $ echo $v1,$v2 2,1\r在这个例子中，v2 被赋值为 v1 的原值，而 v1 在此操作后自增。\n常见运算符\r+：加法 -：减法 *：乘法 /：除法 ++：自增 --：自减 引号和转义\r在使用 let 或其他 Bash 命令时，如果表达式包含特殊字符或空格，通常需要使用引号（\" 或 '）或者反斜杠（\\）进行转义。","基础语法#基础语法":"echo\recho命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。\n$ echo hello world hello world\r如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。\n$ echo \"\u003cHTML\u003e \u003cHEAD\u003e \u003cTITLE\u003ePage Title\u003c/TITLE\u003e \u003c/HEAD\u003e \u003cBODY\u003e Page body. \u003c/BODY\u003e \u003c/HTML\u003e\"\r-n 参数\r默认情况下，echo输出的文本末尾会有一个回车符。-n参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。\n$ echo -n hello world hello world$\r上面例子中，world后面直接就是下一行的提示符$。\n$ echo a;echo b a b $ echo -n a;echo b ab\r-e参数\r-e参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符\\n）。如果不使用-e参数，即默认情况下，引号会让特殊字符变成普通字符，echo不解释它们，原样输出。\n$ echo \"Hello\\nWorld\" Hello\\nWorld # 双引号的情况 $ echo -e \"Hello\\nWorld\" Hello World # 单引号的情况 $ echo -e 'Hello\\nWorld' Hello World\r命令格式\r命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。\n$ command [ arg1 ... [ argN ]]\r短形式与长形式命令配置\r在命令行工具中，许多配置项通常有两种形式：短形式和长形式。短形式一般以一个连字符 - 开头，而长形式则以两个连字符 -- 开头，且两者的功能完全相同。\n短形式：-l（适合手动输入，简洁） 长形式：--list（适合脚本编写，可读性更高，便于理解） 例如，以下两个命令功能一致：\n# 短形式 $ ls -r # 长形式 $ ls --reverse\r在上例中，-r 是短形式，--reverse 是长形式。虽然它们执行相同的功能，但短形式更便于手动输入，而长形式则在脚本中更具可读性。\n多行命令的书写\r通常，Bash 命令写在一行中，按下回车键后立即执行。但如果命令过长，分行书写有助于提高可读性。此时可以在每行末尾使用反斜杠 \\，将下一行与当前行合并解释。例如：\n$ echo foo bar # 等同于 $ echo foo \\ bar\rBash 使用空格（或 Tab 键）区分不同的参数。\r$ command foo bar\r在上面的命令中，foo 和 bar 之间有一个空格，所以 Bash 认为它们是两个参数。\n如果参数之间有多个空格，Bash 会自动忽略多余的空格。例如：\n$ echo this is a test this is a test\r在这个例子中，尽管 a 和 test 之间有多个空格，Bash 依然只会处理为一个空格，输出时没有多余空格。\n分号\r分号（;）是命令的结束符，可以让一行中包含多个命令。前一个命令执行结束后，接着执行下一个命令。\n$ clear; ls\r在此例中，Bash 会先执行 clear 命令，执行完成后再执行 ls 命令。\n需要注意的是，使用分号时，无论第一个命令是否成功执行，第二个命令都会继续执行。\n命令的组合符\u0026\u0026和||\r除了分号，Bash 还提供了两个命令组合符：\u0026\u0026 和 ||，可以更灵活地控制多个命令之间的执行顺序。\nCommand1 \u0026\u0026 Command2\n表示如果 Command1 成功执行，则继续执行 Command2。\nCommand1 || Command2\n表示如果 Command1 执行失败，则继续执行 Command2。\n示例\r$ cat filelist.txt; ls -l filelist.txt\r在这个例子中，无论 cat 命令执行成功还是失败，都会继续执行 ls 命令。\n$ cat filelist.txt \u0026\u0026 ls -l filelist.txt\r在这个例子中，只有 cat 命令成功执行后，才会继续执行 ls 命令。如果 cat 执行失败（如文件不存在），ls 命令将不会执行。\n$ mkdir foo || mkdir bar\r在这个例子中，只有当 mkdir foo 命令执行失败时（如 foo 目录已存在），才会执行 mkdir bar 命令。如果 mkdir foo 成功，bar 目录将不会被创建。\ntype 命令\rtype 命令用于判断 Bash 中一个命令的来源，是内置命令还是外部程序。\n示例\r$ type echo echo is a shell builtin $ type ls ls is hashed (/bin/ls)\r上面的例子中，type 命令告诉我们 echo 是一个内置命令，而 ls 是外部程序（位于 /bin/ls）。\ntype 命令本身也是内置命令：\n$ type type type is a shell builtin\r查看命令的所有定义\r通过 type -a 参数可以查看命令的所有定义：\n$ type -a echo echo is a shell builtin echo is /usr/bin/echo echo is /bin/echo\r在上面的例子中，echo 既是一个内置命令，也有对应的外部程序。\n返回命令类型\rtype -t 参数可以返回命令的类型，可能的结果包括：别名（alias）、关键词（keyword）、函数（function）、内置命令（builtin）、文件（file）。\n$ type -t bash file $ type -t if keyword\r在这个例子中，bash 是一个文件，而 if 是一个关键词。\n快捷键\rBash 提供了许多快捷键，能极大地提高操作效率。以下是一些常用的快捷键，更多细节可以参考《行操作》部分。\nCtrl + L：清屏并将当前行移至页面顶部。 Ctrl + C：中止当前正在执行的命令。 Shift + PageUp：向上滚动查看终端内容。 Shift + PageDown：向下滚动查看终端内容。 Ctrl + U：删除光标位置到行首的内容。 Ctrl + K：删除光标位置到行尾的内容。 Ctrl + W：删除光标前的一个单词。 Ctrl + D：关闭当前 Shell 会话。 ↑，↓：浏览历史命令记录。 自动补全\rBash 还支持自动补全功能。当命令输入到一半时，按下 Tab 键，Bash 会自动补全命令。例如，输入 tou 后按下 Tab 键，Bash 会自动补全为 touch。\n不仅命令支持补全，文件路径也可以自动补全。输入路径的部分内容后按下 Tab 键，Bash 会补全剩余路径。如果有多个可能的选项，按两次 Tab 键，Bash 会显示所有可选路径。","字符串操作#字符串操作":"","引号和转义#引号和转义":"Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。\n在 Bash 中，某些字符具有特殊含义（如 $、\u0026、* 等），如果你想要原样输出这些特殊字符，需要使用反斜杠进行转义。\n特殊字符的转义\r例如，直接输出 $ 符号时，它会被解释为变量符号，因此不会有任何结果：\n$ echo $date # 输出为空\r为了原样输出 $，需要在它前面加反斜杠进行转义：\n$ echo \\$date $date\r反斜杠的转义\r反斜杠 \\ 本身也是一个特殊字符。如果想要输出反斜杠本身，需要对其自身进行转义，使用两个反斜杠 \\\\：\n$ echo \\\\ \\\r表示不可打印字符\r反斜杠还可以用于表示一些不可打印的字符：\n\\a：响铃 \\b：退格 \\n：换行 \\r：回车 \\t：制表符 为了正确输出这些字符，需要使用 echo 命令的 -e 参数，并将字符放在引号中：\n$ echo -e \"a\\tb\" a b\r在不使用 -e 参数时，Bash 不会正确解释这些特殊字符：\n$ echo a\\tb atb\r多行命令的书写\r反斜杠还可以用于将一条命令分成多行书写。在行尾加上反斜杠，Bash 会忽略换行符，将下一行视为同一条命令的延续：\n$ mv \\ /path/to/foo \\ /path/to/bar # 等同于 $ mv /path/to/foo /path/to/bar\r这种写法适用于命令较长的情况下，能够提高命令的可读性。\n通过使用反斜杠进行转义和多行书写，你可以灵活处理 Bash 中的特殊字符和长命令。\n在 Bash 中，单引号用来保留字符的字面含义，所有在单引号内的字符都会被视为普通字符，即使它们通常在 Bash 中具有特殊含义。\n单引号的特点\r保留特殊字符的字面含义：在单引号内，特殊字符如 *、$、\\ 等不会被 Bash 扩展或解释。 示例\r$ echo '*' *\r$ echo '$USER' $USER\r$ echo '$((2+2))' $((2+2))\r$ echo '$(echo foo)' $(echo foo)\r在这些例子中，单引号使得 Bash 的扩展（如变量、算术运算、子命令）失效，所有内容都按字面输出。\n单引号内不能转义\r由于反斜杠 \\ 在单引号内被视为普通字符，所以不能用于转义单引号。如果要在单引号内使用单引号，需要使用 \\$ 形式。\n错误示例\r$ echo it's # 报错，因为单引号没有正确关闭\r$ echo 'it\\'s' # 报错，反斜杠在单引号内不起作用\r正确方法\r可以通过在外层加上 $ 来允许转义单引号：\n$ echo $'it\\'s' it's\r或者更简洁的方式是使用双引号来包含单引号：\n$ echo \"it's\" it's\r总结\r单引号内的内容不会被 Bash 解析或扩展，所有字符都按字面输出。 反斜杠在单引号内不起作用，不能转义单引号。如果需要在单引号内使用单引号，可以使用 $'...' 或改用双引号。 使用单引号时，确保所有字符的含义都不需要 Bash 扩展，否则建议使用双引号。\n双引号\r双引号在 Bash 中的行为比单引号更加宽松，允许某些特殊字符继续发挥它们的作用，而其他字符则会变为普通字符。\n特点\r大部分特殊字符失去特殊含义：例如，通配符 * 在双引号中会失去文件名扩展功能，变为普通字符。 示例\r$ echo \"*\" *\r在这个例子中，* 被当作普通字符，未进行文件名扩展。\n保持特殊含义的字符\r在双引号中，三个字符保持其特殊含义：\n美元符号 $：继续引用变量。 反引号 `：继续执行子命令。 反斜杠 \\：继续作为转义字符。 示例\r$ echo \"$SHELL\" /bin/bash $ echo \"`date`\" Mon Jan 27 13:33:18 CST 2020\r在这个例子中，$SHELL 继续引用变量，`date` 继续执行子命令。\n反斜杠的转义作用\r反斜杠在双引号中仍然保留其转义功能，可以用于插入双引号或反斜杠本身。\n$ echo \"I'd say: \\\"hello.\\\"\" I'd say: \"hello.\" $ echo \"\\\\\" \\\r多行文本\r在双引号中，换行符不再被 Bash 解释为命令的结束符，而只是作为普通的换行符。因此，可以在双引号中输入多行文本。\n$ echo \"hello world\" hello world\r文件名包含空格\r当文件名包含空格时，必须使用双引号或单引号来将文件名括起来，否则 Bash 会将文件名中的空格解释为多个文件名。\n$ ls \"two words.txt\"\r原样保存空格和格式\r双引号可以保留多余的空格，确保输出与输入一致。\n$ echo \"this is a test\" this is a test\r双引号还能保存原始的命令输出格式。如果不使用双引号，Bash 会将所有输出压缩为单行。\n示例\r# 单行输出 $ echo $(cal) 一月 2020 日 一 二 三 四 五 六 1 2 3 ... 31 # 原始格式输出 $ echo \"$(cal)\" 一月 2020 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\r在这个例子中，双引号保留了 cal 命令的原始格式。\n总结\r双引号：保留 $、` 和 \\ 的特殊含义，其他字符变为普通字符。 用途：用于处理包含空格的文件名，保持输出格式，防止 Bash 进行不必要的扩展。 Here 文档\rHere 文档（here document）是一种在 Bash 中输入多行字符串的方法，其格式如下：\n\u003c\u003c token text token\r格式说明\r开始标记：\u003c\u003c token，其中 token 是 Here 文档的名称，可以是任意名称。 结束标记：token，必须单独一行顶格书写。 Here 文档会将开始标记和结束标记之间的所有内容作为输入，并将这些内容提供给一个命令处理。\n示例\r以下是一个通过 Here 文档输出 HTML 代码的示例：\n$ cat \u003c\u003c _EOF_ \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e The title of your page \u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Your page content goes here. \u003c/body\u003e \u003c/html\u003e _EOF_\r在这个例子中，_EOF_ 是 Here 文档的标记，内容是多行 HTML 代码，Bash 会将它们作为输入传递给 cat 命令。\nHere 文档中的变量替换\rHere 文档支持变量替换和反斜杠转义，但是不支持通配符扩展，双引号和单引号在 Here 文档中失去了它们的语法作用。\n示例\r$ foo='hello world' $ cat \u003c\u003c _example_ $foo \"$foo\" '$foo' _example_\r输出：\nhello world \"hello world\" 'hello world'\r在这个例子中，变量 $foo 被替换为其值，但双引号和单引号被原样输出。\n禁用变量替换\r如果希望避免变量替换，可以将 Here 文档的开始标记放在单引号中：\n$ foo='hello world' $ cat \u003c\u003c '_example_' $foo \"$foo\" '$foo' _example_\r输出：\n$foo \"$foo\" '$foo'\r在这个例子中，由于开始标记 _example_ 被单引号包裹，因此变量 $foo 没有被替换。\nHere 文档的作用机制\rHere 文档的本质是重定向。它将字符串重定向给某个命令，相当于 echo 命令的重定向：\n$ command \u003c\u003c token string token\r等同于：\n$ echo string | command\rHere 文档适用于那些能够接受标准输入的命令。它不能作为命令本身的参数，例如 echo 命令不能使用 Here 文档：\n$ echo \u003c\u003c _example_ hello _example_\r在这个例子中，echo 命令不会输出任何内容，因为 Here 文档对 echo 命令无效。\n注意事项\rHere 文档不能作为变量的值，它只能用于命令的参数。 适用于接受标准输入的命令，例如 cat、grep 等，但对于不接受标准输入的命令无效。 Here 文档是一种方便的方式来输入多行文本并将其传递给命令处理，尤其是在处理长文本块时非常有用。\nHere字符串\rHere 字符串（Here string）是 Here 文档的变体，使用三个小于号（\u003c\u003c\u003c）表示，它将一个字符串通过标准输入传递给命令。\n基本语法\r\u003c\u003c\u003c string\rHere 字符串的作用是将给定的字符串传递给命令的标准输入，而不是作为命令的直接参数。这对于一些只接受标准输入的命令非常有用。\n示例\r$ cat \u003c\u003c\u003c 'hi there'\r上面的命令使用 Here 字符串将 'hi there' 传递给 cat 命令，等同于下面的管道命令：\n$ echo 'hi there' | cat\r使用 Here 字符串的语法更加简洁，且语义上更加清晰。\n应用场景\r有些命令只能通过标准输入接收数据，而不能直接将字符串作为参数传递。这时 Here 字符串非常有用。例如 md5sum 命令：\n$ md5sum \u003c\u003c\u003c 'ddd'\r这等同于：\n$ echo 'ddd' | md5sum\r如果你直接运行 md5sum ddd，ddd 会被解释为文件名，而不是字符串内容。因此，使用 Here 字符串可以避免这种误解，将 'ddd' 作为字符串传递给 md5sum。\n总结\rHere 字符串是一个方便的工具，它允许将字符串直接作为标准输入传递给命令，语法简洁且清晰，适用于那些只接受标准输入的命令。","查看shell#查看Shell":"\r$ cat /etc/shells\rbash --version echo $BASH_VERSION","模式扩展#模式扩展":"波浪线扩展\r波浪线 ~ 在 Bash 中会自动扩展为当前用户的主目录。\n$ echo ~ /home/me\r~/dir 表示主目录中的某个子目录，其中 dir 是主目录中的子目录名。\n# 进入 /home/me/foo 目录 $ cd ~/foo\r~user 会扩展为指定用户的主目录：\n$ echo ~foo /home/foo $ echo ~root /root\r如果 ~user 后的用户名不存在，波浪线扩展不会生效，仍然显示原输入内容：\n$ echo ~nonExistedUser ~nonExistedUser\r~+ 会扩展为当前所在的目录，等同于 pwd 命令的结果：\n$ cd ~/foo $ echo ~+ /home/me/foo\r?扩展\r? 字符在 Bash 中用于文件路径扩展，表示任意单个字符，不包括空字符。\n示例\r# 存在文件 a.txt 和 b.txt $ ls ?.txt a.txt b.txt\r在这个例子中，? 代表单个字符，所以会匹配 a.txt 和 b.txt。\n如果要匹配多个字符，可以使用多个 ? 连用。\n# 存在文件 a.txt、b.txt 和 ab.txt $ ls ??.txt ab.txt\r在这个例子中，?? 匹配两个字符，因此 ab.txt 被匹配。\n文件名扩展\r? 字符扩展是文件名扩展的一部分，只有在匹配的文件实际存在时才会生效。如果没有匹配到文件，扩展不会发生。\n# 当前目录有 a.txt 文件 $ echo ?.txt a.txt # 当前目录为空目录 $ echo ?.txt ?.txt\r在这个例子中，如果 ?.txt 匹配到文件名，echo 会输出扩展后的文件名；如果没有匹配到文件，echo 会原样输出 ?.txt。\n* 扩展\r* 字符在 Bash 中用于文件路径扩展，表示任意数量的任意字符，包括零个字符。\n示例\r# 存在文件 a.txt、b.txt 和 ab.txt $ ls *.txt a.txt b.txt ab.txt\r在这个例子中，*.txt 匹配所有以 .txt 结尾的文件。\n如果想输出当前目录的所有文件，直接使用 *：\n$ ls *\r匹配空字符\r* 可以匹配零个或多个字符：\n# 存在文件 a.txt 和 ab.txt $ ls a*.txt a.txt ab.txt\r# 存在文件 b.txt 和 ab.txt $ ls *b* b.txt ab.txt\r隐藏文件匹配\r* 不会匹配隐藏文件（以 . 开头的文件），例如：\n$ ls *\r如果要匹配隐藏文件，需要使用 .*：\n# 显示所有隐藏文件 $ echo .*\r要排除 . 和 .. 这两个特殊的隐藏文件，可以使用以下表达式：\n$ echo .[!.]*\r文件存在条件\r与 ? 字符扩展一样，* 字符扩展只有在匹配的文件存在时才会生效。如果没有匹配到文件，扩展不会发生：\n# 当前目录不存在 c 开头的文件 $ echo c*.txt c*.txt\r在这个例子中，由于目录中没有 c 开头的文件，c*.txt 会原样输出。\n目录匹配\r* 只匹配当前目录中的文件，不会匹配子目录中的文件：\n# 子目录有 a.txt 文件 # 无效写法 $ ls *.txt # 有效写法 $ ls */*.txt\r如果需要匹配多层子目录中的文件，可以使用 */*.txt。对于多层子目录，需要使用相应数量的 * 级别。\nBash 4.0 中的 globstar\rBash 4.0 引入了 globstar 参数，当启用时，** 可以匹配零个或多个子目录。例如：\n# 匹配顶层和任意深度子目录中的所有文本文件 $ ls **/*.txt\rglobstar 允许 **/*.txt 匹配顶层目录和任意深度子目录中的 .txt 文件。更多内容可以参考 shopt 命令的详细介绍。\n方括号扩展\r[start-end] 扩展\n方括号扩展有一个简写形式[start-end]，表示匹配一个连续的范围。比如，[a-c]等同于[abc]，[0-9]匹配[0123456789]。\n# 存在文件 a.txt、b.txt 和 c.txt $ ls [a-c].txt a.txt b.txt c.txt # 存在文件 report1.txt、report2.txt 和 report3.txt $ ls report[0-9].txt report1.txt report2.txt report3.txt\r下面是一些常用简写的例子。\n[a-z]：所有小写字母。 [a-zA-Z]：所有小写字母与大写字母。 [a-zA-Z0-9]：所有小写字母、大写字母与数字。 [abc]*：所有以a、b、c字符之一开头的文件名。 program.[co]：文件program.c与文件program.o。 BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。\r这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。\n$ ls report[!1–3].txt report4.txt report5.txt\n上面代码中，[!1-3]表示排除1、2和3。\n大括号扩展\r大括号扩展 {...} 用于生成一系列的值，括号内的值用逗号分隔。它会扩展为括号内的每一个值，无论对应的文件是否存在。\n示例\r$ echo {1,2,3} 1 2 3 $ echo d{a,e,i,u,o}g dag deg dig dug dog $ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back\r注意，大括号扩展与文件名扩展不同，它会生成所有给定的值，而不考虑是否存在相应的文件：\n$ ls {a,b,c}.txt ls: 无法访问'a.txt': 没有那个文件或目录 ls: 无法访问'b.txt': 没有那个文件或目录 ls: 无法访问'c.txt': 没有那个文件或目录\r注意事项\r逗号前后不能有空格。如果有空格，大括号扩展将失效：\n$ echo {1 , 2} {1 , 2}\r逗号前可以没有值，表示扩展的第一项为空：\n$ cp a.log{,.bak} # 等同于 $ cp a.log a.log.bak\r嵌套大括号扩展\r大括号可以嵌套使用：\n$ echo {j{p,pe}g,png} jpg jpeg png $ echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b\r与其他模式联用\r大括号扩展可以与其他模式（如 *）联用，并且优先于其他模式扩展：\n$ echo /bin/{cat,b*} /bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...\r该命令等同于：\n$ echo /bin/cat; echo /bin/b*\r多字符扩展\r大括号扩展支持多字符模式，而方括号扩展 [abc] 只能匹配单个字符：\n$ echo {cat,dog} cat dog\r文件存在性区别\r大括号扩展始终会扩展，而方括号扩展仅在文件存在时扩展：\n# 不存在 a.txt 和 b.txt $ echo [ab].txt [ab].txt $ echo {a,b}.txt a.txt b.txt\r在这个例子中，如果文件 a.txt 和 b.txt 不存在，方括号扩展 [ab].txt 不会展开，而大括号扩展 {a,b}.txt 依然会生成 a.txt 和 b.txt。\n{start..end} 扩展\r大括号扩展的简写形式 {start..end} 表示生成一个连续的序列。该序列可以是字母或数字。\n示例\r$ echo {a..c} a b c $ echo d{a..d}g dag dbg dcg ddg $ echo {1..4} 1 2 3 4 $ echo Number_{1..5} Number_1 Number_2 Number_3 Number_4 Number_5\r支持逆序\r该扩展还支持逆序生成：\n$ echo {c..a} c b a $ echo {5..1} 5 4 3 2 1\r无法理解的简写\r当 Bash 无法理解某种简写时，它将原样输出：\n$ echo {a1..3c} {a1..3c}\r嵌套扩展\r简写形式支持嵌套使用：\n$ echo .{mp{3..4},m4{a,b,p,v}} .mp3 .mp4 .m4a .m4b .m4p .m4v\r新建目录\r大括号扩展的一个常见用途是新建一系列目录：\n$ mkdir {2007..2009}-{01..12}\r这条命令会新建 36 个子目录，格式为“年份-月份”。\n用于循环\r在 for 循环中也常用大括号扩展：\nfor i in {1..4} do echo $i done\r这个循环会执行 4 次，输出 1 到 4。\n前导零\r如果起始数字有前导零，输出的每一项都会保留前导零：\n$ echo {01..5} 01 02 03 04 05 $ echo {001..5} 001 002 003 004 005\r步长指定\r可以使用第二个双点号 {start..end..step} 来指定步长：\n$ echo {0..8..2} 0 2 4 6 8\r在这个例子中，数字从 0 递增到 8，每次增加 2。\n连用扩展\r多个简写形式连用时，会有循环处理效果：\n$ echo {a..c}{1..3} a1 a2 a3 b1 b2 b3 c1 c2 c3\r这会生成所有可能的组合结果。\nBash 中的变量扩展、子命令扩展、算术扩展和字符类扩展都是常见的扩展操作，以下是详细介绍：\n变量扩展\r使用 $ 符号来引用变量，Bash 会将其扩展为变量的值：\n$ echo $SHELL /bin/bash\r变量也可以使用 ${} 进行引用：\n$ echo ${SHELL} /bin/bash\r使用 ${!string*} 或 ${!string@} 可以返回所有匹配指定前缀的变量名：\n$ echo ${!S*} SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK\r子命令扩展\r子命令扩展使用 $(...) 语法，可以将另一个命令的运行结果作为返回值：\n$ echo $(date) Tue Jan 28 00:01:13 CST 2020\r另一种较老的语法是使用反引号 `...`：\n$ echo `date` Tue Jan 28 00:01:13 CST 2020\r子命令扩展支持嵌套，例如：\n$ echo $(ls $(pwd))\r算术扩展\r使用 ((...)) 进行整数运算，并返回结果：\n$ echo $((2 + 2)) 4\r字符类扩展\r字符类 [[:class:]] 用于匹配特定类型的字符。常用字符类如下：\n[[:alnum:]]：字母或数字 [[:alpha:]]：字母 [[:blank:]]：空格和 Tab [[:cntrl:]]：控制字符（ASCII 码 0-31） [[:digit:]]：数字 [[:graph:]]：可打印字符（不含空格） [[:lower:]]：小写字母 [[:print:]]：可打印字符（含空格） [[:punct:]]：标点符号 [[:space:]]：空白字符 [[:upper:]]：大写字母 [[:xdigit:]]：十六进制字符 例如，列出所有以大写字母开头的文件：\n$ echo [[:upper:]]*\r字符类可以通过加 ! 或 ^ 来表示否定：\n$ echo [![:digit:]]*\r使用注意点\r通配符先解释再执行\nBash 会先扩展通配符，然后执行命令：\n$ ls a*.txt ab.txt\r文件名扩展原样输出\n如果没有匹配的文件，通配符原样输出：\n$ echo r* r*\r通配符仅匹配单层路径\n* 和 ? 只能匹配当前目录的文件，无法匹配子目录。如果要匹配子目录中的文件，可以使用 */：\n$ ls */*.txt\r文件名中使用通配符\n如果文件名中包含通配符，需要使用引号引起来：\n$ touch 'fo*' $ ls fo*\r这些扩展功能帮助你灵活操作 Bash 命令和文件路径。\n量词语法\rBash 中的量词语法用来控制模式匹配的次数，但需要 extglob 参数开启。一般情况下，extglob 是默认打开的，你可以使用以下命令来检查或开启它：\n$ shopt extglob extglob on $ shopt -s extglob # 开启 extglob\r量词语法\r?(pattern-list)：匹配零次或一次模式。 *(pattern-list)：匹配零次或多次模式。 +(pattern-list)：匹配一次或多次模式。 @(pattern-list)：只匹配一次模式。 !(pattern-list)：匹配给定模式以外的任何内容。 示例\r$ ls abc?(.)txt abctxt abc.txt\r?(.) 匹配零个或一个点。\n$ ls abc?(def) abc abcdef\r?(def) 匹配零个或一个 def。\n$ ls abc@(.txt|.php) abc.php abc.txt\r@(.txt|.php) 只匹配 .txt 或 .php 后缀的文件。\n$ ls abc+(.txt) abc.txt abc.txt.txt\r+(.txt) 匹配一个或多个 .txt。\n$ ls a!(b).txt a.txt abb.txt ac.txt\r!(b) 匹配非 b 的内容。\nshopt 命令\rshopt 命令可以控制 Bash 的一些行为，特别是通配符扩展相关的参数：\ndotglob：匹配包括隐藏文件（以 . 开头的文件）。\n$ shopt -s dotglob $ ls * abc.txt .config\rnullglob：当没有匹配文件时，通配符返回空字符串。\n$ shopt -s nullglob $ rm b* # 如果没有 b* 匹配的文件，rm 不会报错。\rfailglob：当没有匹配文件时，直接报错。\n$ shopt -s failglob $ rm b* # 如果没有匹配文件，Bash 会直接报错。 bash: 无匹配: b*\rextglob：支持扩展的通配符语法（如量词语法），默认开启。\n$ shopt -s extglob\rnocaseglob：通配符扩展不区分大小写。\n$ shopt -s nocaseglob $ ls /windows/program* /windows/ProgramData /windows/Program Files /windows/Program Files (x86)\rglobstar：允许 ** 匹配零个或多个子目录。默认关闭。\n假设有如下文件结构：\na.txt sub1/b.txt sub1/sub2/c.txt\r默认情况下，你需要分层写出通配符来匹配子目录：\n$ ls *.txt */*.txt */*/*.txt\r开启 globstar 后，**/*.txt 可以匹配所有子目录中的 .txt 文件：\n$ shopt -s globstar $ ls **/*.txt a.txt sub1/b.txt sub1/sub2/c.txt\r通过这些选项，Bash 的通配符扩展可以变得更加灵活和强大，满足各种复杂文件匹配的需求。"},"title":"Bash"},"/docs/coding/examples/estimating-building-heights/":{"data":{"作业说明#作业说明：":"","使用数字高程模型dems和openstreetmap数据估算建筑物高度#使用数字高程模型（DEMs）和OpenStreetMap数据估算建筑物高度":"","参考文献#参考文献:":"使用数字高程模型（DEMs）和OpenStreetMap数据估算建筑物高度目标：\r在本次作业中，您将利用数字高程模型（DEMs）和来自OpenStreetMap（OSM）的建筑物轮廓数据，估算荷兰瓦赫宁根市建筑物的高度。目标是开发一个简单的城市环境三维（3D）模型，这对于城市规划、噪声传播估算、太阳能分析和阴影分析等应用至关重要。\n背景：\r建筑物的三维建模在城市规划、基础设施开发和环境影响评估等各种城市应用中变得越来越重要。拥有可靠的建筑物高度信息使城市规划者能够精确评估新开发项目对周边区域的影响，例如其对风模式、阴影投射和城市整体美观的影响。这些分析不仅对于确保城市可持续增长至关重要，而且对于优化建筑物和公共空间的能源效率也非常关键。最终，这些努力有助于通过创造更宜居、有韧性且规划良好的城市环境来提升居民的生活质量。\n然而，关于建筑物第三维度（即高度）的信息往往有限。尽管OpenStreetMap提供了广泛的建筑物轮廓数据，但其中标注了高度信息的建筑物不足3%（Sun, 2021）。因此，唯一可行的大规模估算建筑物高度的方法是通过遥感数据。\n一种有效的确定建筑物高度的方法是使用冠层高度模型（CHM）。CHM计算了地面与物体（如建筑物和树木）顶部之间的垂直距离。要生成CHM，需要将捕捉裸地高程的数字地形模型（DTM）与包含地表所有特征的高程的数字表面模型（DSM）进行相减。\n作业说明：\r数据收集： DTM数据：使用以下链接下载所选区域的数字地形模型（DTM）数据：https://service.pdok.nl/rws/ahn/atom/dtm_05m.xml。使用以下图块：Kaartblad M_39FZ1, M_39FZ2, M_39FN1, M_39FN2。 DSM数据：使用以下链接下载数字表面模型（DSM）数据：https://service.pdok.nl/rws/ahn/atom/dsm_05m.xml。使用以下图块：Kaartblad R_39FZ1, R_39FZ2, R_39FN1, R_39FN2。 数据处理： CHM创建：编写一个Python函数，通过将DTM从DSM中相减来生成冠层高度模型（CHM）。确保您的函数能够处理多个图块，并将它们整合为研究区域的单一CHM。 建筑高度提取：使用OpenStreetMap的建筑物轮廓数据，提取覆盖建筑物轮廓的CHM数据。这将为您提供估算的建筑高度。 输出： 生成一个表示瓦赫宁根选定区域建筑高度的栅格数据集。 建筑高度比较：正如引言中所述，OpenStreetMap只为有限数量的建筑物提供了高度数据。使用提取的CHM数据，并与OpenStreetMap提供的建筑高度进行比较。 提交一份报告，详细说明您的方法，包括遇到的挑战以及如何解决这些挑战。 参考文献:\rSun, Yao (2021), Large-scale LoD1 Building Model Reconstruction from a Single SAR Image. Doctoral thesis. URL: https://elib.dlr.de/187104/2/1615447.pdf","目标#目标：":"","背景#背景：":""},"title":"Estimating Building Heights"},"/docs/coding/python/basic/1/":{"data":{"":"本章概述了两种基本的地理数据模型–矢量和栅格，并介绍了处理它们的主要 Python 软件包。在演示它们在 Python 中的实现之前，我们将介绍每种数据模型背后的理论以及它们主要应用的学科。\n矢量数据模型（第 1.2 节）使用点、线和多边形来表示世界。这些数据具有离散、明确的边界，这意味着矢量数据集通常具有较高的精度（但不一定准确）。 另一方面，栅格数据模型（第 1.3 节）将表面划分为大小不变的单元格。栅格数据集是网络制图中使用的背景图像的基础，自航空摄影和卫星遥感设备诞生以来，栅格数据集一直是地理数据的重要来源。栅格将特定的空间特征聚合到一个给定的分辨率，这意味着它们在空间上是一致的，并且可以扩展，有许多世界范围的栅格数据集可用。 使用哪个？答案可能取决于您的应用领域以及您有权访问的数据集：\n矢量数据集和方法在社会科学中占主导地位，因为人类住区和过程（例如交通基础设施）往往具有离散的边界 由于对遥感数据的依赖，栅格数据集和方法在许多环境科学中占据主导地位 Python 对这两种数据模型都有强大的支持。我们将重点关注用于处理地理矢量数据的 shapely 和 geopandas，以及用于处理栅格的 rasterio。\n有多个部分重叠的用于处理栅格数据的软件包，每个都有其优点和缺点。在本书中，我们重点介绍最突出的一个：rasterio。它通过将“简单的”栅格数据集与 numpy 数组相结合，并使用一个元数据对象（字典）提供地理元数据（如坐标系）来表示。xarray 是另一个值得注意的替代方案，但本书没有涵盖。它使用原生的 xarray.Dataset 和 xarray.DataArray 类来有效表示复杂的栅格数据集，例如具有多个波段和元数据的‘NetCDF’文件。\n在某些领域中存在大量重叠，栅格数据和矢量数据可以一起使用。例如，生态学家和人口统计学家常常同时使用矢量和栅格数据。此外，这两种数据形式可以相互转换（见第 5 章）。无论你的工作更侧重于矢量数据还是栅格数据，在使用它们之前，理解基础的数据模型都是值得的，正如后续章节所讨论的那样。","坐标参考系-crs#坐标参考系 (CRS)":"矢量和栅格空间数据类型共享空间数据固有的概念。其中最基本的可能是坐标参考系 (CRS)，它定义了数据的空间元素与地球（或其他天体）表面的关系。CRS 分为地理和投影坐标参考系，正如本章开始时介绍的那样（见 1.2 节）。本节解释了每种类型，为第 6 章的深入讨论奠定基础，后者将深入探讨设置、转换和查询 CRS。\n地理坐标系统\n地理坐标系统通过两个值——经度和纬度——来识别地球表面的任何位置（参见图 1.26 左侧）。经度是东西方向上相对于本初子午线平面的角距离，纬度是相对于赤道平面的北或南的角距离。因此，在地理 CRS 中，距离不是以米为单位测量的，这会产生重要的影响，正如第 6 章中所示。\n在地理坐标系统中，地球表面通常表示为球形或椭球形表面。球形模型假设地球是一个给定半径的完美球体——它们的优点是简单，但同时它们不准确：地球并不是一个球体！椭球模型由两个参数定义：赤道半径和极半径。这些模型适用于地球因为其被压缩的形状：赤道半径比极半径长约 11.5 公里。尽管地球也不是一个椭球体，但它比球体更接近实际情况。\n椭球体是 CRS 的一个更广泛组成部分：基准面。基准面包含了使用哪个椭球体以及笛卡尔坐标与地球表面位置之间的精确关系的信息。基准面有两种类型——地心基准面（如 WGS84）和本地基准面（如 NAD83）。图 1.25 展示了这两种基准面的示例。黑线表示地心基准面，其中心位于地球的重心处，没有为特定位置进行优化。图中的紫色虚线表示本地基准面，椭球体表面经过移动，以与特定位置的地表对齐。这允许本地 CRS 考虑地球表面上的局部变化，例如大型山脉。图 1.25 显示了本地基准面与菲律宾区域对齐，但与地球表面的其他大部分区域不一致。这两种基准面都放置在地球平均海平面模型——大地水准面之上。\n图 1.25：显示在大地水准面上的地心和本地大地基准（使用假彩色和 10,000 倍垂直夸大比例）。大地水准面的图像改编自 Ince 等人（2019）的作品。\n投影坐标参考系统\n所有投影 CRS 都基于上一节中描述的地理 CRS，并依赖地图投影将地球的三维表面转换为投影 CRS 中的东向和北向（x 和 y）值。投影 CRS 基于隐式平面表面上的笛卡尔坐标（参见图 1.26 右侧）。它们有一个原点、x 和 y 轴，以及以米为单位的线性测量单位。\n这种转换不能在不增加变形的情况下进行。因此，地球表面的某些属性（如面积、方向、距离和形状）在此过程中会发生变形。投影坐标系统只能保留这些属性中的一个或两个。投影通常以保留的属性命名：等面积投影保留面积，方位投影保留方向，等距投影保留距离，等角投影保留局部形状。\n投影类型主要分为三大类：圆锥投影、圆柱投影和平面投影（方位投影）。在圆锥投影中，地球表面被投影到一个沿着单条切线或两条切线的圆锥上。沿切线的变形最小，距离切线越远，变形越大。因此，它最适合用于中纬度地区的地图。圆柱投影将地表映射到一个圆柱体上。此投影也可以通过沿单条切线或两条切线与地球表面接触来创建。圆柱投影最常用于绘制世界地图。平面投影将数据投影到一个在某点或沿切线接触地球的平面上。它通常用于极地地区的制图。\nPython 中的 CRS\n与大多数开源地理空间软件一样，geopandas 和 rasterio 包使用 PROJ 软件来定义和计算 CRS。pyproj 包是 PROJ 的低级接口。使用它的函数（如 get_codes 和 from_epsg），我们可以查看 PROJ 支持的投影列表。\nimport pyproj epsg_codes = pyproj.get_codes('EPSG', 'CRS') # 支持的 EPSG 代码 epsg_codes[:5] # 打印前五个支持的 EPSG 代码\r输出：\n['10150', '10151', '10156', '10157', '10158']\r使用 EPSG 代码 4326 打印 WGS84 CRS：\npyproj.CRS.from_epsg(4326)\r输出：\n\u003cGeographic 2D CRS: EPSG:4326\u003e Name: WGS 84 Axis Info [ellipsoidal]: - Lat[north]: Geodetic latitude (degree) - Lon[east]: Geodetic longitude (degree) Area of Use: - name: World. - bounds: (-180.0, -90.0, 180.0, 90.0) Datum: World Geodetic System 1984 ensemble - Ellipsoid: WGS 84 - Prime Meridian: Greenwich\r关于不同投影类型、属性和适用性的快速总结可以在 geo-projections 网站 上找到。我们将在第 6 章中进一步扩展 CRS，并解释如何在不同 CRS 之间进行转换。但目前只需了解以下几点：\n坐标系统是地理对象的关键组成部分。 了解数据所处的 CRS，以及它是地理 CRS（经度/纬度）还是投影 CRS（通常以米为单位），非常重要，这会影响 Python 如何处理空间和几何操作。 可以使用 .crs 属性查询 geopandas（矢量图层或几何列）和 rasterio（栅格）对象的 CRS。 以下是最后一点的演示，我们导入一个矢量图层并确定其 CRS（在本例中是投影 CRS，即 UTM 第 12 区），使用 .crs 属性：\nzion = gpd.read_file('data/zion.gpkg') zion.crs\r输出：\n\u003cBound CRS: PROJCS[\"UTM Zone 12, Northern Hemisphere\",GEOGCS[\" ...\u003e Name: UTM Zone 12, Northern Hemisphere Axis Info [cartesian]: - [east]: Easting (Meter) - [north]: Northing (Meter) Area of Use: - undefined Coordinate Operation: - name: Transformation from GRS 1980(IUGG, 1980) to WGS84 - method: Position Vector transformation (geog2D domain) Datum: unknown - Ellipsoid: GRS80 - Prime Meridian: Greenwich Source CRS: UTM Zone 12, Northern Hemisphere\r我们还可以通过在两种 CRS 中绘制 zion 数据来展示地理 CRS 和投影 CRS 之间的差异（如图 1.26 所示）。注意，我们使用 matplotlib 的 .grid 方法在绘图上添加网格线。\n# WGS84 zion.to_crs(4326).plot(edgecolor='black', color='lightgrey').grid() # NAD83 / UTM 第 12 区 zion.plot(edgecolor='black', color='lightgrey').grid();\r图 1.26：矢量图层的坐标参考系统 (CRS) 示例\n我们将在第 6 章中详细讨论如何将一个 CRS 重投影到另一个 CRS（如上面的代码段中的 .to_crs）。\n单位\nCRS 的一个重要功能是包含空间单位的信息。显然，了解房屋的测量单位是英尺还是米是至关重要的，地图也是如此。一个好的制图实践是在地图上添加比例尺或其他距离指示器，以显示页面或屏幕上的距离与地面距离之间的关系。同样，用户了解几何坐标的单位也很重要，以确保后续计算在正确的上下文中进行。\n在 geopandas 和 rasterio 中的 Python 空间数据结构本质上不支持度量单位的概念。矢量图层或栅格的坐标只是普通数字，指的是一个任意的平面。例如，查看 srtm.tif 的 .transform 矩阵可以发现栅格的分辨率是 0.000833，并且其 CRS 是 WGS84（EPSG: 4326）：\nsrc.meta {'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 65535.0, 'width': 465, 'height': 457, 'count': 1, 'crs': CRS.from_epsg(4326), 'transform': Affine(0.0008333333332777796, 0.0, -113.23958321278403, 0.0, -0.0008333333332777843, 37.512916763165805)}\r你可能已经知道 WGS84 坐标系（EPSG: 4326）的单位是十进制度。然而，这一信息不会被纳入任何数值计算中，这意味着诸如缓冲区的操作可能会返回以度为单位的结果，这在大多数情况下是不合适的。\n因此，你应该始终了解数据集的 CRS 及其使用的单位。通常情况下，这些单位是在地理 CRS 中的十进制度，或在投影 CRS 中的米，尽管也有例外。几何计算（如长度、面积或距离）以与 CRS 单位相同的单位返回普通数字（如米或平方米）。用户需要自己确定结果所使用的单位，并相应地处理结果。例如，如果面积输出是以平方米为单位的，而我们需要的结果是平方公里，那么我们需要将结果除以 1,000,000。","栅格数据#栅格数据":"空间栅格数据模型通过连续的网格单元（通常也称为像素；图 1.19 (A)）来表示世界。该数据模型通常指所谓的规则网格，其中每个单元的大小相同且恒定——在本书中我们将仅关注规则网格。不过，也存在其他类型的网格，包括旋转网格、剪切网格、直角网格和曲线网格（参见 Pebesma 和 Bivand (2022) 第 1 章或 Tennekes 和 Nowosad (2022) 第 2 章）。\n栅格数据模型通常由栅格头文件（或元数据）和表示等距单元（通常称为像素）的矩阵（具有行和列）组成（图 1.19 (A)）。栅格头文件定义了坐标参考系、原点和分辨率。原点（或起点）通常是矩阵左下角的坐标。元数据定义了原点和单元大小，即分辨率。结合列数和行数，可以推导出栅格的范围。\n图 1.19：栅格数据类型：（A）单元格 ID，（B）单元格值，（C）彩色栅格地图\n栅格地图通常用于表示连续现象，如海拔、高温、人口密度或光谱数据。离散特征（例如土壤类型或土地覆盖分类）也可以通过栅格数据模型来表示。图 1.20 中展示了栅格数据集的这两种用途，显示了离散特征的边界在栅格数据集中可能会变得模糊。根据应用的性质，使用矢量表示离散特征可能会更加合适。\n图 1.20：连续栅格和分类栅格示例\n如前所述，与处理矢量图层和 geopandas 相比，Python 中处理栅格数据的方法并没有围绕一个全面的软件包展开。相反，不同的软件包提供了处理栅格数据的替代方法。\nPython 中处理栅格数据的两个主要方法分别由 rasterio 和 rioxarray 软件包提供。它们的范围和底层数据模型有所不同。具体来说，rasterio 使用 numpy 数组表示栅格，并通过单独的对象存储空间元数据。而 rioxarray 是 rasterio 的包装器，它使用 xarray“扩展”数组表示栅格，这是 numpy 数组的扩展，能够在同一对象中保存轴标签和属性，以及栅格值数组。类似的方法还由较少知名的 xarray-spatial 和 geowombat 软件包提供。相比之下，rasterio 更成熟，但它更偏低级（这既有优点也有缺点）。\n然而，上述所有软件包都不像 geopandas 那样全面。例如，在使用 rasterio 时，可能还需要其他软件包来完成常见任务，如区域统计（rasterstats 软件包）或计算地形指数（richdem 软件包）。\n在接下来的两个小节中，我们将介绍 rasterio，这是我们将在本书中使用的栅格相关软件包。\n使用 rasterio\n要使用 rasterio 软件包，首先需要导入它。另外，由于栅格数据存储在 numpy 数组中，我们还需导入 numpy 软件包，以便有效地操作数据。最后，我们导入 rasterio.plot 子模块中的 rasterio.plot.show 函数，用于快速可视化栅格数据。\nimport numpy as np import rasterio import rasterio.plot\r栅格数据通常是从现有文件中导入的。在使用 rasterio 时，导入栅格数据实际上是一个两步过程：\n首先，使用 rasterio.open 打开栅格文件的“连接”。 然后，使用 .read 方法从连接中读取栅格值。 这种分离方式类似于 Python 中用于读取文件的基本函数，例如使用 open 和 .readline 从文本文件中读取。其背后的逻辑是我们不总是希望将文件中的所有信息读入内存，这一点在栅格数据的大小可能超过内存时尤为重要。因此，第二步（.read）是选择性的，用户可以精细调整实际读取的数据子集（波段、行/列、分辨率等）。例如，我们可能只想读取一个栅格波段，而不是读取所有波段。\n在第一步中，我们将文件路径传递给 rasterio.open 函数，以创建一个 DatasetReader 文件连接，命名为 src。在此示例中，我们使用一个存储在 srtm.tif 文件中的单波段栅格，表示锡安国家公园的海拔。\nsrc = rasterio.open('data/srtm.tif') src\r输出：\n\u003copen DatasetReader name='data/srtm.tif' mode='r'\u003e\r为了对栅格数据有一个初步印象，我们可以使用 rasterio.plot.show 函数绘制栅格数据（如图 1.21 所示）：\nrasterio.plot.show(src);\r图 1.21：栅格的基本绘图，数据来自 rasterio 文件连接\nDatasetReader 包含栅格的元数据，即除栅格值之外的所有信息。我们可以使用 .meta 属性来查看这些元数据。\nsrc.meta\r输出结果：\n{'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 65535.0, 'width': 465, 'height': 457, 'count': 1, 'crs': CRS.from_epsg(4326), 'transform': Affine(0.0008333333332777796, 0.0, -113.23958321278403, 0.0, -0.0008333333332777843, 37.512916763165805)}\r这些元数据包括以下属性，我们将在后面的章节中详细介绍：\ndriver：栅格文件格式 dtype：数据类型 nodata：表示“无数据”的标记值 尺寸： width：列数 height：行数 count：波段数 crs：坐标参考系统 transform：栅格仿射变换矩阵 最后一项（即 transform）值得特别关注。要将栅格定位到地理空间中，除了 CRS 外，还必须指定栅格的原点（x_min，y_max）和分辨率（delta_x，delta_y）。在变换矩阵的表示中，假设网格是规则的，数据项的存储方式如下：\nAffine(delta_x, 0.0, x_min, 0.0, delta_y, y_max)\r注意，按照惯例，栅格 y 轴的原点设为最大值（y_max）而不是最小值，因此 y 轴分辨率（delta_y）为负数。换句话说，由于原点位于左上角，沿着 y 轴前进时是向下移动的（负方向）。\n第二步，使用 DatasetReader 的 .read 方法读取实际的栅格值。重要的是，我们可以读取以下内容：\n所有波段（如 .read()） 某个特定波段，传入数字索引（如 .read(1)） 波段子集，传入索引列表（如 .read([1,2])） 注意，波段索引从 1 开始，这与 Python 的索引从 0 开始的惯例不同。\n.read 返回的对象是一个 numpy 数组，具有二维或三维：\n如果读取多个波段（如 .read() 或 .read([1,2])），则返回的数组为三维，维度模式为 (波段，行，列)。 如果读取特定波段（如 .read(1)），则返回的数组为二维，维度模式为 (行，列)。 现在，我们使用文件连接对象 src 和 .read 方法读取 srtm.tif 栅格的第一个（也是唯一一个）波段。\nsrc.read(1)\r输出结果是一个二维 numpy 数组，每个值代表相应像素的海拔高度。\narray([[1728, 1718, 1715, ..., 2654, 2674, 2685], [1737, 1727, 1717, ..., 2649, 2677, 2693], [1739, 1734, 1727, ..., 2644, 2672, 2695], ..., [1326, 1328, 1329, ..., 1777, 1778, 1775], [1320, 1323, 1326, ..., 1771, 1770, 1772], [1319, 1319, 1322, ..., 1768, 1770, 1772]], dtype=uint16)\r图 1.22 总结了 rasterio 文件连接与派生属性之间的关系。通过 rasterio.open 创建的文件连接可以访问栅格数据的两个组成部分：元数据（通过 .meta 属性）和栅格值（通过 .read 方法）。\n图 1.22：从零开始创建 GeoDataFrame\n从零开始创建栅格数据\n在本节中，我们将演示如何从零开始创建栅格数据。我们将构建两个小的栅格数据 elev 和 grain，稍后将在本书的示例中使用。与创建矢量图层（见 1.2.6 节）不同，从零开始创建栅格数据在实际中很少需要，因为要编程方式对齐栅格的空间范围具有挑战性（GIS 软件中的“地理配准”工具更适合这类工作）。尽管如此，这些示例将有助于熟悉 rasterio 的数据结构。\n概念上，栅格是一个数组与地理参考信息的结合，而后者包括：\n一个变换矩阵，包含原点和分辨率，将像素索引与特定坐标系统中的坐标关联起来 一个 CRS 定义，指定该坐标系统与地球表面的关联（可选） 因此，要创建栅格，我们首先需要一个包含值的数组，然后补充地理参考信息。我们来创建 elev 和 grain 数组。elev 数组是一个 6x6 的数组，包含从 1 到 36 的顺序值。可以使用 numpy 的 np.arange 函数和 .reshape 方法创建它：\nelev = np.arange(1, 37, dtype=np.uint8).reshape(6, 6) elev\r输出：\narray([[ 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24], [25, 26, 27, 28, 29, 30], [31, 32, 33, 34, 35, 36]], dtype=uint8)\rgrain 数组表示一个分类栅格，值为 0、1、2，分别对应于类别“黏土”（clay）、“粉砂”（silt）、“沙”（sand）。我们将使用 numpy 的 np.array 和 .reshape 函数创建它：\nv = [ 1, 0, 1, 2, 2, 2, 0, 2, 0, 0, 2, 1, 0, 2, 2, 0, 0, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 0, 2 ] grain = np.array(v, dtype=np.uint8).reshape(6, 6) grain\r输出：\narray([[1, 0, 1, 2, 2, 2], [0, 2, 0, 0, 2, 1], [0, 2, 2, 0, 0, 2], [0, 0, 1, 1, 1, 1], [1, 1, 1, 2, 1, 1], [2, 1, 2, 2, 0, 2]], dtype=uint8)\r注意，在两个示例中，我们都使用了 uint8 数据类型（8 位无符号整数，即 0-255），这足以表示给定栅格的所有可能值。这是推荐的做法，可以将内存占用最小化。\n现在缺少的是地理参考信息（见 1.3.1 节）。在这个例子中，由于栅格是任意的，我们也设置了一个任意的变换矩阵，其中：\n原点 (x_min, y_max) 在 (-1.5, 1.5) 栅格分辨率 (delta_x, delta_y) 是 (0.5, -0.5) 我们可以使用 rasterio.transform.from_origin 添加此信息，并指定 west、north、xsize 和 ysize 参数。生成的变换矩阵对象命名为 new_transform：\nnew_transform = rasterio.transform.from_origin( west=-1.5, north=1.5, xsize=0.5, ysize=0.5 ) new_transform\r输出：\nAffine(0.5, 0.0, -1.5, 0.0, -0.5, 1.5)\r注意，尽管 ysize 实际上是负数（-0.5），在 rasterio.transform.from_origin 中使用正值（0.5）来定义。\n现在，我们可以将数组 elev 与变换矩阵 new_transform 一起传递给 rasterio.plot.show，在其坐标系中绘制栅格数据（如图 1.23 所示）：\nrasterio.plot.show(elev, transform=new_transform);\r图 1.23：elev 栅格的绘图，一个从零开始创建的连续栅格的简单示例\ngrain 栅格可以用同样的方法绘制，因为我们将为它使用相同的变换矩阵（如图 1.24 所示）。\nrasterio.plot.show(grain, transform=new_transform);\r图 1.24：grain 栅格的绘图，一个从零开始创建的分类栅格的简单示例\n此时，我们已经有了两个栅格数据，每个都由一个数组和相关的变换矩阵组成。我们可以通过以下方式使用 rasterio 处理栅格数据：\n在栅格像素坐标重要的地方传递变换矩阵（例如在 rasterio.plot.show 函数中） 记住我们在分析中使用的任何其他图层都必须在相同的 CRS 中 最后，为了将栅格导出到永久存储，同时保留空间元数据，我们需要执行以下步骤：\n创建一个栅格文件连接（在此过程中我们设置 transform 和 CRS 等其他设置） 将栅格值数组写入连接 关闭连接 如果以下代码暂时不清楚，不必担心；将栅格数据写入文件的相关概念会在第 7.6.2 节中解释。为了完整性，也为了在后续章节中使用这些栅格文件而无需重新创建，我们提供了将 elev 和 grain 栅格导出到输出目录的代码。对于 elev，我们使用 rasterio.open、.write 和 .close 方法进行导出。\nnew_dataset = rasterio.open( 'output/elev.tif', 'w', driver='GTiff', height=elev.shape[0], width=elev.shape[1], count=1, dtype=elev.dtype, crs=4326, transform=new_transform ) new_dataset.write(elev, 1) new_dataset.close()\r注意，我们为 elev 栅格任意设置的 CRS 是 WGS84，使用 crs=4326（根据 EPSG 代码定义）。\n导出 grain 栅格的方式相同，唯一的区别是文件名和写入连接的数组。\nnew_dataset = rasterio.open( 'output/grain.tif', 'w', driver='GTiff', height=grain.shape[0], width=grain.shape[1], count=1, dtype=grain.dtype, crs=4326, transform=new_transform ) new_dataset.write(grain, 1) new_dataset.close()\r结果是 elev.tif 和 grain.tif 文件被写入输出目录。我们将在后续示例中使用这些小型栅格文件（例如第 2.3.1 节）。\n需要注意的是，elev 和 grain 的变换矩阵和尺寸是相同的。这意味着这些栅格是重叠的，并且可以组合成一个包含两个波段的栅格，用于栅格代数操作（见第 3.3.2 节）等。","矢量数据#矢量数据":"地理矢量数据模型基于位于坐标参考系 (CRS) 内的点。点可以表示独立的特征（例如，公交站的位置），或者它们可以连接在一起形成更复杂的几何图形，如线和多边形。大多数点的几何形状仅包含两个维度（三维 CRS 可能包含一个附加的 z 值，通常表示高于海平面的高度）。\n在该系统中，例如，伦敦可以用坐标 (-0.1, 51.5) 表示。这意味着它的位置是距离原点向东 -0.1 度，向北 51.5 度。在这里，原点是指 0 度经度（位于格林尼治的本初子午线）和 0 度纬度（赤道）在地理 CRS 中的坐标（‘经纬度’ CRS）。相同的点也可以用投影的 CRS 近似表示，其‘东坐标/北坐标’值为 (530000, 180000) 在英国国家网格中，这意味着伦敦位于 CRS 原点以东 530 公里，以北 180 公里的位置。英国国家网格的原点位置位于英国西南半岛以外的海域，确保了英国大多数地点的东坐标和北坐标为正值。\n图 1.1：矢量（点）数据的示意图，其中伦敦的位置（红色 X）是相对于原点（蓝色圆圈）表示的。左侧图表示一个地理坐标参考系 (CRS)，其原点位于 0° 经度和纬度。右侧图表示一个投影的坐标参考系，其原点位于西南半岛以西的海域。\n坐标参考系 (CRS) 涉及的内容更多，如第 1.4 节和第 6 章所述，但在本节的目的中，了解坐标由两个数字组成，表示距原点的距离，通常在两个维度中表示，这已足够。\ngeopandas (Bossche 等，2023) 提供了用于地理矢量数据的类和一致的命令行接口，方便在 Python 中进行可重复的地理数据分析。它还提供了三个成熟的地理计算库的接口，结合起来，构成了许多地理应用（包括 QGIS 和 R 的空间生态系统）的坚实基础：\nGDAL：用于读取、写入和操作各种地理数据格式，详细内容见第 7 章。 PROJ：一个用于坐标系统转换的强大库，相关内容见第 6 章。 GEOS：一个用于执行操作的平面几何引擎，如计算具有投影 CRS 的数据的缓冲区和质心，详细内容见第 4 章。 与这些地理库的紧密集成使得可重复的地理计算成为可能：使用 Python 这样的高级语言访问这些库的一个优势在于，你不需要了解底层组件的复杂性，从而能够专注于方法，而不是实现。\n矢量数据类\n用于处理 Python 中地理矢量数据的主要类是分层的，这意味着最高级别的“矢量图层”类是由更简单的“几何列”和单个“几何”组件组成的。本节将按顺序介绍这些类，从最高级别的类开始。对于许多应用来说，高级别的矢量图层类（本质上是带有几何列的数据框）已经足够使用。然而，理解矢量地理对象的结构及其组成部分，对于更高级的应用是非常重要的。Python 中的三种主要矢量地理数据类如下：\nGeoDataFrame：表示矢量图层的类，包含一个几何列（类为 GeoSeries）。 GeoSeries：用于表示 GeoDataFrame 对象中的几何列的类。 shapely 几何对象：用于表示单个几何形状（如点或多边形）的类，存在于 GeoSeries 对象中。 前两个类（GeoDataFrame 和 GeoSeries）由 geopandas 定义。第三个类是由 shapely 包定义的，它处理单个几何形状，并且是 geopandas 包的主要依赖之一。\n矢量图层\n最常用的地理矢量数据结构是矢量图层。在 Python 中处理矢量图层有多种方法，从低级别的软件包（例如 osgeo，fiona）到本节重点讨论的相对高级的 geopandas 包。在编写和运行代码以创建和处理地理矢量对象之前，我们需要导入 geopandas（按照惯例缩写为 gpd 以使代码更简洁）和 shapely。\nimport pandas as pd import shapely import geopandas as gpd\r我们还通过使用 pandas 的 display.max_rows 选项将打印的最大行数限制为 6 行，以节省空间。\npd.set_option('display.max_rows', 6)\r项目通常从导入现有的矢量图层开始，这些图层保存为 GeoPackage (.gpkg) 文件、ESRI Shapefile (.shp) 或其他地理文件格式。函数 gpd.read_file 将位于 Python 工作目录的 data 目录中的名为 world.gpkg 的 GeoPackage 文件导入为一个名为 gdf 的 GeoDataFrame。\ngdf = gpd.read_file('data/world.gpkg')\r结果是一个 GeoDataFrame 类型的对象，具有 177 行（要素）和 11 列，如以下代码的输出所示：\ntype(gdf) # geopandas.geodataframe.GeoDataFrame gdf.shape # (177, 11)\rGeoDataFrame 类是 pandas 包中 DataFrame 类的扩展（McKinney 2010）。这意味着我们可以将矢量图层中的非空间属性视为表格，并使用普通的、即非空间的函数方法来处理它们。例如，可以使用标准的数据帧子集方法。以下代码创建了 gdf 数据集的一个子集，仅包含国家名称和几何列。\ngdf = gdf[['name_long', 'geometry']] gdf\r输出示例：\nname_long geometry Fiji MULTIPOLYGON (((-180 -16.55522,… Tanzania MULTIPOLYGON (((33.90371 -0.95,… Western Sahara MULTIPOLYGON (((-8.66559 27.656… … … Kosovo MULTIPOLYGON (((20.59025 41.855… Trinidad and Tobago MULTIPOLYGON (((-61.68 10.76, -… South Sudan MULTIPOLYGON (((30.83385 3.5091… 177 行 × 2 列\n以下表达式基于条件创建一个子数据集，例如 name_long 列的值等于字符串 “Egypt”。\ngdf[gdf['name_long'] == 'Egypt']\r输出示例：\nname_long geometry Egypt MULTIPOLYGON (((36.86623 22, 36… 最后，为了了解矢量图层的空间组件，可以使用 .plot 方法进行绘制（图 1.2）。\ngdf.plot();\r图 1.2：GeoDataFrame 的基本绘图\n可以使用 .explore 方法创建 GeoDataFrame 对象的交互式地图，正如图 1.3 所示。以下命令用于生成该交互式地图：\ngdf.explore()\rFigure 1.3: Basic interactive map with .explore\nA subset of the data can be also plotted in a similar fashion.\ngdf[gdf['name_long'] == 'Egypt'].explore()\r图 1.4：GeoDataFrame 子集的交互式地图\n1.2.3 几何列\nGeoSeries 类的几何列是 GeoDataFrame 中的重要列，它包含了矢量图层的几何部分，并且是所有空间操作的基础。可以通过列名访问该列，通常（例如从文件中读取时）其名称为 ‘geometry’，如 gdf['geometry']。不过，推荐使用固定的 .geometry 属性来访问几何列，无论列名是否是 ‘geometry’。对于 gdf 对象来说，几何列包含了与每个国家相关联的 ‘MultiPolygon’。\ngdf.geometry\r输出：\n0 MULTIPOLYGON (((-180 -16.55522,... 1 MULTIPOLYGON (((33.90371 -0.95,... 2 MULTIPOLYGON (((-8.66559 27.656... ... 174 MULTIPOLYGON (((20.59025 41.855... 175 MULTIPOLYGON (((-61.68 10.76, -... 176 MULTIPOLYGON (((30.83385 3.5091... Name: geometry, Length: 177, dtype: geometry\r几何列还包含空间参考信息（可以通过 gdf.crs 访问）。\ngdf.geometry.crs\r输出：\n\u003cGeographic 2D CRS: EPSG:4326\u003e Name: WGS 84 Axis Info [ellipsoidal]: - Lat[north]: Geodetic latitude (degree) - Lon[east]: Geodetic longitude (degree) Area of Use: - name: World. - bounds: (-180.0, -90.0, 180.0, 90.0) Datum: World Geodetic System 1984 ensemble - Ellipsoid: WGS 84 - Prime Meridian: Greenwich\r许多几何操作，比如计算质心、缓冲区或每个要素的边界框，涉及的仅仅是几何列。因此，在 GeoDataFrame 上应用此类操作基本上是对几何列 GeoSeries 对象进行操作的快捷方式。例如，以下两个命令返回完全相同的结果，都是一个包含国家边界框多边形的 GeoSeries（使用 .envelope 方法）。\ngdf.envelope gdf.geometry.envelope\r输出：\n0 POLYGON ((-180 -18.28799, 179.9... 1 POLYGON ((29.34 -11.72094, 40.3... 2 POLYGON ((-17.06342 20.99975, -... ... 174 POLYGON ((20.0707 41.84711, 21.... 175 POLYGON ((-61.95 10, -60.895 10... 176 POLYGON ((23.88698 3.50917, 35.... Length: 177, dtype: geometry\r注意 .envelope 和 geopandas 中的其他类似操作符（如 .centroid、.buffer 或 .convex_hull）仅返回几何（即 GeoSeries），而不是带有原始属性数据的 GeoDataFrame。如果我们想要后者，可以复制 GeoDataFrame，然后“覆盖”其几何列（或者，如果不需要原始几何列，可以直接覆盖它们，如 gdf.geometry = gdf.envelope）。\ngdf2 = gdf.copy() gdf2.geometry = gdf.envelope gdf2\r输出示例：\nname_long geometry Fiji POLYGON ((-180 -18.28799, 179.9… Tanzania POLYGON ((29.34 -11.72094, 40.3… Western Sahara POLYGON ((-17.06342 20.99975, -… … … Kosovo POLYGON ((20.0707 41.84711, 21…. Trinidad and Tobago POLYGON ((-61.95 10, -60.895 10… South Sudan POLYGON ((23.88698 3.50917, 35…. 177 行 × 2 列\n几何列的另一个有用的属性是几何类型，如下代码所示。注意，几何列（以及矢量图层）中包含的几何类型并不一定在每一行都相同。一个 GeoSeries 中可以包含多个几何类型。因此，.type 属性返回的是一个 Series（其值类型为字符串 str），而不是单一值（同样可以通过快捷方式 gdf.geom_type 实现）。\ngdf.geometry.type\r输出：\n0 MultiPolygon 1 MultiPolygon 2 MultiPolygon ... 174 MultiPolygon 175 MultiPolygon 176 MultiPolygon Length: 177, dtype: object\r为了总结几何列中不同几何类型的出现情况，可以使用 pandas 的 .value_counts 方法。在本例中，我们可以看到 gdf 图层只包含 ‘MultiPolygon’ 几何类型。\ngdf.geometry.type.value_counts()\r输出：\nMultiPolygon 177 Name: count, dtype: int64\r一个 GeoDataFrame 还可以拥有多个 GeoSeries 列，如下面代码所示。\ngdf['bbox'] = gdf.envelope gdf['polygon'] = gdf.geometry gdf\r一次只能有一个几何列是“活动的”，即它参与与几何相关的操作（如 .centroid、.crs 等）。要将活动几何列从一个 GeoSeries 列切换到另一个，可以使用 .set_geometry。图 1.5 和图 1.6 显示了 gdf 图层在 ‘bbox’ 和 ‘polygon’ 几何列激活时的交互式地图。\ngdf = gdf.set_geometry('bbox') gdf.explore()\rFigure 1.5: Switching to the ‘bbox’ geometry column in the world layer, and plotting it\ngdf = gdf.set_geometry('polygon') gdf.explore()\rSimple Features 标准\n几何体是矢量图层的基本构建块。虽然 Simple Features 标准定义了大约 20 种几何类型，但我们将重点关注七种最常用的类型：POINT（点）、LINESTRING（线）、POLYGON（多边形）、MULTIPOINT（多点）、MULTILINESTRING（多线）、MULTIPOLYGON（多边形）和 GEOMETRYCOLLECTION（几何集合）。在 R 语言的 sf 包文档中可以找到所有可能的几何类型的有用列表。\nSimple Features 几何体可以通过 well-known binary (WKB) 和 well-known text (WKT) 编码表示。WKB 通常是计算机易于读取的十六进制字符串，因此 GIS 软件和空间数据库使用 WKB 来传输和存储几何对象。WKT 是人类可读的文本标记描述，描述 Simple Features。两种格式是可互换的，如果我们要展示一种格式，通常会选择 WKT 表示法。\n每种几何类型的基础是点。点是二维、三维或四维空间中的一个坐标点，如图 1.7 所示。\nPOINT (5 2)\r线串 (LINESTRING) 是一系列点，点与点之间通过直线相连（图 1.8）。\nLINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\r多边形 (POLYGON) 是一系列点，这些点形成一个闭合的、无交叉的环。闭合意味着多边形的第一个和最后一个点具有相同的坐标（图 1.9）。\nPOLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\r到目前为止，我们只创建了每个要素中包含一个几何实体的几何体。然而，Simple Features 标准允许在一个要素中存在多个几何实体，使用几何类型的“多”版本，如图 1.10、图 1.11 和图 1.12 所示。\nMULTIPOINT (5 2, 1 3, 3 4, 3 2) MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4)) MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\r最后，几何集合 (GEOMETRYCOLLECTION) 可以包含其他六种类型的几何体的任意组合，如下图所示，包含一个多点和一个线串的组合（图 1.13）。\nGEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\r1.2.5 几何体\n几何列（GeoSeries）中的每个元素都是一个 shapely 类的几何对象（Gillies 等，2007–）。例如，以下是 gdf 的几何列中按隐式索引选出的一个特定几何体（加拿大，gdf.geometry 列中的第 4 个元素）。\ngdf.geometry.iloc[3]\rWe can also select a specific geometry based on the name_long attribute (i.e., the 1st and only element in the subset of gdf where the country name is equal to Egypt):\ngdf[gdf['name_long'] == 'Egypt'].geometry.iloc[0]\rshapely 包兼容 Simple Features 标准（见 1.2.4 节），因此支持七种几何类型。以下部分演示了如何从头创建每种 shapely 几何对象。在第一个示例中（创建一个 ‘Point’），我们展示了创建几何对象的两种输入类型：坐标列表或 WKT（Well-Known Text）格式的字符串。在其余几何类型的示例中，我们使用前一种方法（坐标列表）。\n要从坐标列表创建一个 ‘Point’ 几何对象，可以使用 shapely.Point 函数，如以下表达式所示（图 1.7）：\npoint = shapely.Point([5, 2]) point\r此代码会创建一个表示点的几何对象，其中点的坐标为 (5, 2)。\nFigure 1.7: A Point geometry (created either from a list or WKT)\nAlternatively, we can use shapely.from_wkt to transform a WKT string to a shapely geometry object. Here is an example of creating the same ‘Point’ geometry from WKT (Figure 1.7).\npoint = shapely.from_wkt('POINT (5 2)') point\rA ‘LineString’ geometry can be created based on a list of coordinate tuples or lists (Figure 1.8).\nlinestring = shapely.LineString([(1,5), (4,4), (4,1), (2,2), (3,2)]) linestring\rFigure 1.8: A LineString geometry\nCreation of a ‘Polygon’ geometry is similar, but our first and last coordinate must be the same, to ensure that the polygon is closed. Note that in the following example, there is one list of coordinates that defines the exterior outer hull of the polygon, followed by a list of lists of coordinates that define the holes (if any) in the polygon (Figure 1.9).\npolygon = shapely.Polygon( [(1,5), (2,2), (4,1), (4,4), (1,5)], ## Exterior [[(2,4), (3,4), (3,3), (2,3), (2,4)]] ## Hole(s) ) polygon\rA ‘MultiPoint’ geometry is also created from a list of coordinate tuples (Figure 1.10), where each element represents a single point.\nmultipoint = shapely.MultiPoint([(5,2), (1,3), (3,4), (3,2)]) multipoint\rFigure 1.10: A MultiPoint geometry\nA ‘MultiLineString’ geometry, on the other hand, has one list of coordinates for each line in the MultiLineString (Figure 1.11).\nmultilinestring = shapely.MultiLineString([ [(1,5), (4,4), (4,1), (2,2), (3,2)], ## 1st sequence [(1,2), (2,4)] ## 2nd sequence, etc. ]) multilinestring\rFigure 1.11: A MultiLineString geometry\nA ‘MultiPolygon’ geometry (Figure 1.12) is created from a list of Polygon geometries. For example, here we are creating a ‘MultiPolygon’ with two parts, both without holes.\nmultipolygon = shapely.MultiPolygon([ [[(1,5), (2,2), (4,1), (4,4), (1,5)], []], ## Polygon 1 [[(0,2), (1,2), (1,3), (0,3), (0,2)], []] ## Polygon 2, etc. ]) multipolygon\rFigure 1.12: A MultiPolygon geometry\nSince the required input has four hierarchical levels, it may be more clear to create the single-part ‘Polygon’ geometries in advance, using the respective function (shapely.Polygon), and then pass them to shapely.MultiPolygon (Figure 1.12). (The same technique can be used with the other shapely.Multi* functions.)\nmultipolygon = shapely.MultiPolygon([ shapely.Polygon([(1,5), (2,2), (4,1), (4,4), (1,5)]), ## Polygon 1 shapely.Polygon([(0,2), (1,2), (1,3), (0,3), (0,2)]) ## Polygon 2, etc. ]) multipolygon\rAnd, finally, a ‘GeometryCollection’ geometry is a list with one or more of the other six geometry types (Figure 1.13):\ngeometrycollection = shapely.GeometryCollection([multipoint, multilinestring]) geometrycollection\rshapely 几何对象作为矢量数据的原子单位，这意味着不存在几何集合的概念：每个操作都接受单个几何对象作为输入，并返回一个单个几何对象作为输出。（在 geopandas 中定义的 GeoSeries 和 GeoDataFrame 对象用于处理 shapely 几何对象的集合）。例如，以下表达式计算了一个缓冲的 multipolygon（缓冲距离为 0.2）与其自身之间的差异（参见 4.2.5 节），以及缓冲操作（参见 4.2.3 节）（如图 1.14 所示）：\nfrom shapely.geometry import MultiPolygon from shapely.ops import unary_union # 创建一个示例 MultiPolygon multipolygon = MultiPolygon([[(0, 0), (1, 1), (1, 0), (0, 0)], [(2, 2), (3, 3), (3, 2), (2, 2)]]) # 缓冲操作 (距离为 0.2) buffered_multipolygon = multipolygon.buffer(0.2) # 计算缓冲后的 MultiPolygon 与其自身的差异 difference = buffered_multipolygon.difference(multipolygon) difference\r在这个例子中，首先对 multipolygon 应用了缓冲操作，然后计算了缓冲后的几何对象与原始几何对象的差异。shapely 几何对象的这些基本操作返回的也是单个几何对象。\nmultipolygon.buffer(0.2).difference(multipolygon)\r图 1.14：缓冲后的 MultiPolygon 与其自身的差异\n正如前几张图所示，当使用支持显示的界面（如 Jupyter Notebook）时，shapely 几何对象会自动显示为该几何体的小型图像。如果想打印 WKT（Well-Known Text）格式的字符串，可以使用 print 函数：\nprint(linestring) # 输出 LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\r最后，重要的是要注意到 shapely 几何对象的原始坐标可以通过 .coords、.geoms、.exterior 和 .interiors 属性进行访问，具体取决于几何体的类型。这些访问方法在需要开发自己的空间操作符时非常有用。例如，以下表达式返回多边形几何体外部轮廓的所有坐标列表：\nlist(polygon.exterior.coords) # 输出 [(1.0, 5.0), (2.0, 2.0), (4.0, 1.0), (4.0, 4.0), (1.0, 5.0)]\r另见第 4.2.8 节，其中使用 .coords、.geoms 和 .exterior 来将给定的 shapely 几何体转换为不同的类型（例如，将 ‘Polygon’ 转换为 ‘MultiPoint’）。\n从零开始创建矢量图层\n在前面的章节中，我们从现有的 GeoPackage 文件中导入了一个矢量图层（GeoDataFrame），并“分解”它以提取几何列（GeoSeries，见第 1.2.3 节）和单个几何体（shapely，见第 1.2.5 节）。在本节中，我们将演示相反的过程，如何从 shapely 几何体构建一个 GeoDataFrame，并将它们组合成一个 GeoSeries。这将帮助你更好地理解 GeoDataFrame 的结构，并在你需要以编程方式构建简单的矢量图层（例如，在两个给定点之间绘制线段）时提供帮助。\n矢量图层由两部分组成：几何体和非地理属性。图 1.15 显示了如何创建一个 GeoDataFrame 对象——几何体来自 GeoSeries 对象（由 shapely 几何体组成），而属性来自 Series 对象。\n最终结果，一个矢量图层（GeoDataFrame），因此是一个层次结构（如图 1.16 所示），它包含一个几何列（GeoSeries），而几何列内部包含几何对象（shapely）。每个“内部”组件都可以访问或“提取”，有时这是必要的，后续章节中我们将看到这种情况。\n图 1.16：GeoDataFrame 的结构\n非地理属性可以表示特征的名称，以及其他属性，例如测量值、组等。为了说明属性的使用，我们将表示 2023 年 6 月 21 日伦敦的温度为 25°C。这个示例包含一个几何体（坐标）以及三个具有不同数据类型的属性（地点名称、温度和日期）。GeoDataFrame 类的对象通过将属性（Series）与简单特征几何列（GeoSeries）结合在一起来表示这样的数据。首先，我们创建一个点几何体，正如我们在 1.2.5 节中学习的那样（如图 1.17 所示）。\n几何体\n几何列（GeoSeries）中的每个元素都是一个 shapely 类的几何对象（Gillies 等，2007–）。例如，以下是通过隐式索引选取的一个具体几何体（加拿大，是 gdf 几何列中的第 4 个元素）。\n现在，让我们创建伦敦的点几何体：\nlnd_point = shapely.Point(0.1, 51.5) lnd_point\r这会创建一个表示伦敦位置的 Point 对象，坐标为 (0.1, 51.5)。\n图 1.17：表示伦敦的 shapely 点\n接下来，我们创建一个包含该点和 CRS 定义的 GeoSeries（长度为 1），在本例中使用 WGS84（通过 EPSG 代码 4326 定义）。还需要注意的是，shapely 几何体被放入一个列表中，以说明在其他情况下可以包含多个几何体，而不仅限于当前示例中的一个几何体。\nlnd_geom = gpd.GeoSeries([lnd_point], crs=4326) lnd_geom\r输出：\n0 POINT (0.1 51.5) dtype: geometry\r接下来，我们将 GeoSeries 与其他属性组合到一个字典中。几何列是一个名为 geometry 的 GeoSeries。其他属性（如果有）可以使用列表或 Series 对象定义。在这里，为了简化，我们使用列表定义三个属性：名称（name）、温度（temperature）和日期（date）。再次注意，列表的长度可以大于 1，以便我们为多个要素创建图层（即多个行）。\nlnd_data = { 'name': ['London'], 'temperature': [25], 'date': ['2023-06-21'], 'geometry': lnd_geom }\r最后，可以将字典转换为 GeoDataFrame 对象，如下代码所示：\nlnd_layer = gpd.GeoDataFrame(lnd_data) lnd_layer\r输出：\nname temperature date geometry London 25 2023-06-21 POINT (0.1 51.5) 发生了什么？\n首先，使用坐标创建了一个简单的 shapely 几何对象。 然后，该几何对象被转换为包含 CRS 的 GeoSeries（简单特征几何列）。 最后，将属性与 GeoSeries 组合在一起。最终结果是一个名为 lnd_layer 的 GeoDataFrame 对象。 创建包含多个要素的图层示例\n为了展示如何创建包含多个要素的图层，下面是一个包含两个点（伦敦和巴黎）的图层示例：\nlnd_point = shapely.Point(0.1, 51.5) paris_point = shapely.Point(2.3, 48.9) towns_geom = gpd.GeoSeries([lnd_point, paris_point], crs=4326) towns_data = { 'name': ['London', 'Paris'], 'temperature': [25, 27], 'date': ['2013-06-21', '2013-06-21'], 'geometry': towns_geom } towns_layer = gpd.GeoDataFrame(towns_data) towns_layer\r输出：\nname temperature date geometry London 25 2013-06-21 POINT (0.1 51.5) Paris 27 2013-06-21 POINT (2.3 48.9) 创建交互式地图\n现在，我们可以创建 towns_layer 对象的交互式地图（如图 1.18 所示）。为了使点更容易看到，我们自定义了填充颜色和大小（在第 8.3 节中将详细讨论 .explore 的选项）。\ntowns_layer.explore(color='red', marker_kwds={'radius': 10})\r图 1.18：从零开始创建的 towns_layer，使用 .explore 可视化\n空间点图层也可以从包含坐标列的 DataFrame 对象（使用 pandas 包）创建。为了演示，我们首先从坐标创建一个 GeoSeries 对象，然后将其与 DataFrame 结合，形成一个 GeoDataFrame。\ntowns_table = pd.DataFrame({ 'name': ['London', 'Paris'], 'temperature': [25, 27], 'date': ['2017-06-21', '2017-06-21'], 'x': [0.1, 2.3], 'y': [51.5, 48.9] }) towns_geom = gpd.points_from_xy(towns_table['x'], towns_table['y']) towns_layer = gpd.GeoDataFrame(towns_table, geometry=towns_geom, crs=4326)\r输出与之前创建的 towns_layer 相同。这种方法在我们需要从 CSV 文件读取数据时特别有用，例如使用 pd.read_csv，并将生成的 DataFrame 转换为 GeoDataFrame（见第 3.2.3 节的另一个示例）。\n派生数值属性\n矢量图层有两个重要的派生数值属性：长度（.length）——适用于线，和面积（.area）——适用于多边形。面积和长度可以对上述任意数据结构进行计算：如果是 shapely 几何体，返回值是一个数字；如果是 GeoSeries 或 GeoDataFrame，返回值是一个数值 Series。\nlinestring.length # 输出：9.39834563766817 multipolygon.area # 输出：8.0 gpd.GeoSeries([point, linestring, polygon, multipolygon]).area # 输出： 0 0.0 1 0.0 2 6.0 3 8.0 dtype: float64\r与 geopandas 中所有数值计算一样，结果假设为平面坐标参考系 (CRS) 并返回其原生单位。这意味着，对于在 WGS84（crs=4326）中的几何体，长度和面积以十进制度表示，因此没有实际意义（运行 gdf.area 可以看到警告）。\n为了获得地理 CRS 中有意义的长度和面积测量结果，几何体首先需要转换为适用于感兴趣区域的投影 CRS（见第 6.7 节）。例如，斯洛文尼亚的面积可以在 UTM 第 33N 区域的 CRS 中计算（crs=32633），结果以 UTM 第 33N 区域的单位表示。\ngdf[gdf['name_long'] == 'Slovenia'].to_crs(32633).area # 输出： 150 1.910410e+10 dtype: float64"},"title":"1"},"/docs/coding/r/basic/":{"data":{"":"Shapefile\nlibrary(sf) pathshp \u003c- system.file(\"shape/nc.shp\", package = \"sf\")\rshape └── nc.shp └── nc.shx └── nc.dbf └── nc.prj\nmap \u003c- st_read(pathshp, quiet = TRUE) class(map)\rprint(map)\rSimple feature collection with 100 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 Geodetic CRS: NAD27 First 10 features: AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 1 0.114 1.442 1825 1825 Ashe 37009 37009 5 1091 1 2 0.061 1.231 1827 1827 Alleghany 37005 37005 3 487 0 3 0.143 1.630 1828 1828 Surry 37171 37171 86 3188 5 4 0.070 2.968 1831 1831 Currituck 37053 37053 27 508 1 5 0.153 2.206 1832 1832 Northampton 37131 37131 66 1421 9 6 0.097 1.670 1833 1833 Hertford 37091 37091 46 1452 7 7 0.062 1.547 1834 1834 Camden 37029 37029 15 286 0 8 0.091 1.284 1835 1835 Gates 37073 37073 37 420 0 9 0.118 1.421 1836 1836 Warren 37185 37185 93 968 4 10 0.124 1.428 1837 1837 Stokes 37169 37169 85 1612 1 NWBIR74 BIR79 SID79 NWBIR79 geometry 1 10 1364 0 19 MULTIPOLYGON (((-81.47276 3... 2 10 542 3 12 MULTIPOLYGON (((-81.23989 3... 3 208 3616 6 260 MULTIPOLYGON (((-80.45634 3... 4 123 830 2 145 MULTIPOLYGON (((-76.00897 3... 5 1066 1606 3 1197 MULTIPOLYGON (((-77.21767 3... 6 954 1838 5 1237 MULTIPOLYGON (((-76.74506 3... 7 115 350 2 139 MULTIPOLYGON (((-76.00897 3... 8 254 594 2 371 MULTIPOLYGON (((-76.56251 3... 9 748 1190 2 844 MULTIPOLYGON (((-78.30876 3... 10 160 2038 5 176 MULTIPOLYGON (((-80.02567 3... st_crs(map)\rhead(st_drop_geometry(map))\rst_geometry(map)\rMULTIPOLYGON (((-81.47276 36.23436, -81.54084 3... MULTIPOLYGON (((-81.23989 36.36536, -81.24069 3…\nMULTIPOLYGON (((-80.45634 36.24256, -80.47639 3…\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 36…\nMULTIPOLYGON (((-77.21767 36.24098, -77.23461 3…\nsummary(map)\rst_geometry_type(map)\rplot(map[1]) # plot first attribute\rst_bbox(map)\rdim(map) # 数据框的行数（代表几何体的数量）和列数（包括属性列和几何列）。\rstr(map)\rClasses 'sf' and 'data.frame':\t100 obs. of 15 variables: $ AREA : num 0.114 0.061 0.143 0.07 0.153 0.097 0.062 0.091 0.118 0.124 ... $ PERIMETER: num 1.44 1.23 1.63 2.97 2.21 ... $ CNTY_ : num 1825 1827 1828 1831 1832 ... $ CNTY_ID : num 1825 1827 1828 1831 1832 ... $ NAME : chr \"Ashe\" \"Alleghany\" \"Surry\" \"Currituck\" ... $ FIPS : chr \"37009\" \"37005\" \"37171\" \"37053\" ... $ FIPSNO : num 37009 37005 37171 37053 37131 ... $ CRESS_ID : int 5 3 86 27 66 46 15 37 93 85 ... $ BIR74 : num 1091 487 3188 508 1421 ... $ SID74 : num 1 0 5 1 9 7 0 0 4 1 ... $ NWBIR74 : num 10 10 208 123 1066 ... $ BIR79 : num 1364 542 3616 830 1606 ... $ SID79 : num 0 3 6 2 3 5 2 2 2 5 ... $ NWBIR79 : num 19 12 260 145 1197 ... $ geometry :sfc_MULTIPOLYGON of length 100; first list element: List of 1 ..$ :List of 1 .. ..$ : num [1:27, 1:2] -81.5 -81.5 -81.6 -81.6 -81.7 ... ..- attr(*, \"class\")= chr [1:3] \"XY\" \"MULTIPOLYGON\" \"sfg\" - attr(*, \"sf_column\")= chr \"geometry\" - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... ..- attr(*, \"names\")= chr [1:14] \"AREA\" \"PERIMETER\" \"CNTY_\" \"CNTY_ID\" ... library(terra) pathraster \u003c- system.file(\"ex/elev.tif\", package = \"terra\") r \u003c- terra::rast(pathraster) r plot(r)\rdim(r)\rext(r)\rres(r)\rcrs(r)\rminmax(r)\rglobal(r, fun = \"mean\", na.rm = TRUE)\rst_crs(\"EPSG:4326\")$Name\rst_crs(\"EPSG:4326\")$proj4string\rst_crs(\"EPSG:4326\")$epsg\rst_crs(map)$epsg\rst_crs(map)$proj4string\rst_crs(map)$Name\rFunctions sf::st_crs() and terra::crs() allow us to get the CRS of spatial data. These functions also allow us to set a CRS to spatial data by using st_crs(x) \u003c- value if x is a sf object, and crs(r) \u003c- value if r is a raster. Notice that setting a CRS does not transform the data, it just changes the CRS label. We may want to set a CRS to data that does not come with CRS, and the CRS should be what it is, not what we would like it to be. We use sf::st_transform() and terra::project() to transform the sf or raster data, respectively, to a new CRS.\nmap2 \u003c- st_transform(map, crs = \"EPSG:4326\") st_crs(map2)\rst_crs(map2)$Name\rcrs(r)\rr2 \u003c- terra::project(r, \"EPSG:2169\") crs(r2)\r# r2 is existing raster # r is raster we project r3 \u003c- terra::project(r, r2)\rlibrary(sf) pathshp \u003c- system.file(\"shape/nc.shp\", package = \"sf\") nc \u003c- st_read(pathshp, quiet = TRUE) class(nc)\rdim(nc)\rprint(nc)\rSimple feature collection with 100 features and 14 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 Geodetic CRS: NAD27 First 10 features: AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 1 0.114 1.442 1825 1825 Ashe 37009 37009 5 1091 1 2 0.061 1.231 1827 1827 Alleghany 37005 37005 3 487 0 3 0.143 1.630 1828 1828 Surry 37171 37171 86 3188 5 4 0.070 2.968 1831 1831 Currituck 37053 37053 27 508 1 5 0.153 2.206 1832 1832 Northampton 37131 37131 66 1421 9 6 0.097 1.670 1833 1833 Hertford 37091 37091 46 1452 7 7 0.062 1.547 1834 1834 Camden 37029 37029 15 286 0 8 0.091 1.284 1835 1835 Gates 37073 37073 37 420 0 9 0.118 1.421 1836 1836 Warren 37185 37185 93 968 4 10 0.124 1.428 1837 1837 Stokes 37169 37169 85 1612 1 NWBIR74 BIR79 SID79 NWBIR79 geometry 1 10 1364 0 19 MULTIPOLYGON (((-81.47276 3... 2 10 542 3 12 MULTIPOLYGON (((-81.23989 3... 3 208 3616 6 260 MULTIPOLYGON (((-80.45634 3... 4 123 830 2 145 MULTIPOLYGON (((-76.00897 3... 5 1066 1606 3 1197 MULTIPOLYGON (((-77.21767 3... 6 954 1838 5 1237 MULTIPOLYGON (((-76.74506 3... 7 115 350 2 139 MULTIPOLYGON (((-76.00897 3... 8 254 594 2 371 MULTIPOLYGON (((-76.56251 3... 9 748 1190 2 844 MULTIPOLYGON (((-78.30876 3... 10 160 2038 5 176 MULTIPOLYGON (((-80.02567 3... plot(nc)\rWarning message: \"plotting the first 10 out of 14 attributes; use max.plot = 14 to plot all\" colnames(nc)\rnc$AREA\rclass(nc$AREA)\rnc$AREA[1]\rclass(nc$AREA[1])\rhead(map)\rgeom_column \u003c- st_geometry(map) # extract the sfc objects from the sf object print(geom_column)\rGeometry set for 100 features Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 Geodetic CRS: NAD27 First 5 geometries: MULTIPOLYGON (((-81.47276 36.23436, -81.54084 3... MULTIPOLYGON (((-81.23989 36.36536, -81.24069 3…\nMULTIPOLYGON (((-80.45634 36.24256, -80.47639 3…\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 36…\nMULTIPOLYGON (((-77.21767 36.24098, -77.23461 3…\n# extract the first geometry single_geometry \u003c- geom_column[[1]] # sfg (simple feature geometry): a single geometry print(single_geometry)\rMULTIPOLYGON (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.63306 36.34069, -81.74107 36.39178, -81.69828 36.47178, -81.7028 36.51934, -81.67 36.58965, -81.3453 36.57286, -81.34754 36.53791, -81.32478 36.51368, -81.31332 36.4807, -81.26624 36.43721, -81.26284 36.40504, -81.24069 36.37942, -81.23989 36.36536, -81.26424 36.35241, -81.32899 36.3635, -81.36137 36.35316, -81.36569 36.33905, -81.35413 36.29972, -81.36745 36.2787, -81.40639 36.28505, -81.41233 36.26729, -81.43104 36.26072, -81.45289 36.23959, -81.47276 36.23436))) class(geom_column) class(single_geometry)\r# Single point (point as a vector) p1_sfg \u003c- st_point(c(2, 2)) p2_sfg \u003c- st_point(c(2.5, 3)) # Set of points (points as a matrix) p \u003c- rbind(c(6, 2), c(6.1, 2.6), c(6.8, 2.5), c(6.2, 1.5), c(6.8, 1.8)) mp_sfg \u003c- st_multipoint(p) # Polygon. Sequence of points that form a closed, # non-self intersecting ring. # The first ring denotes the exterior ring, # zero or more subsequent rings denote holes in the exterior ring p1 \u003c- rbind(c(10, 0), c(11, 0), c(13, 2), c(12, 4), c(11, 4), c(10, 0)) p2 \u003c- rbind(c(11, 1), c(11, 2), c(12, 2), c(11, 1)) pol_sfg \u003c- st_polygon(list(p1, p2)) # Create sf object p_sfc \u003c- st_sfc(p1_sfg, p2_sfg, mp_sfg, pol_sfg) df \u003c- data.frame(TEST = c(\"A\", \"B\", \"C\", \"D\")) p_sf \u003c- st_sf(df, geometry = p_sfc)\rclass(df)\rclass(p_sf)\rprint(p_sf)\rSimple feature collection with 4 features and 1 field Geometry type: GEOMETRY Dimension: XY Bounding box: xmin: 2 ymin: 0 xmax: 13 ymax: 4 CRS: NA TEST geometry 1 A POINT (2 2) 2 B POINT (2.5 3) 3 C MULTIPOINT ((6 2), (6.1 2.6... 4 D POLYGON ((10 0, 11 0, 13 2,... plot(p_sf)\rlibrary(ggplot2) ggplot(p_sf) + geom_sf(aes(col = TEST), size = 3) + theme_bw()\rst_*() functions\nCommon functions to manipulate sf objects include the following:\nst_read() reads a sf object, st_write() writes a sf object, st_crs() gets or sets a new coordinate reference system (CRS), st_transform() transforms data to a new CRS, st_intersection() intersects sf objects, st_union() combines several sf objects into one, st_simplify() simplifies a sf object, st_coordinates() retrieves coordinates of a sf object, st_as_sf() converts a foreign object to a sf object. For example, we can read a sf object as follows:\nlibrary(sf) library(ggplot2) map \u003c- read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\rmap$FIPS\r# Delete polygon map \u003c- map[-which(map$FIPS %in% c(\"37125\", \"37051\", \"37077\")), ] # 是查找 map 数据框中 FIPS 列的值是 \"37125\" 或 \"37051\" 的行索引 # -which(...) 的作用是排除掉这些行 dim(map) ggplot(map) + geom_sf(aes(fill = SID79)) # 用 SID79 列的值来填充颜色 # geom_sf() 是用于绘制 sf 对象的几何体（如多边形、线、点）的函数 # Combine geometries new_map \u003c- st_union(map, by_feature = FALSE) ggplot(new_map %\u003e% st_sf()) + geom_sf() dim(new_map) # st_union() 函数将多个几何体合并为一个 # by_feature = FALSE 表示将所有的几何体合并为单个几何对象，而不是保持原有的多个单独几何对象 # by_feature = TRUE 表示将所有的几何体合并为单个几何对象，并保留原有的多个单独几何对象 new_map1 \u003c- st_union(map, by_feature = TRUE) ggplot(new_map1 %\u003e% st_sf()) + geom_sf() dim(new_map1) # Simplify ggplot(st_simplify(new_map, dTolerance = 10000)) + geom_sf() ggplot(st_simplify(new_map1, dTolerance = 10000)) + geom_sf() dim(new_map1)\rlibrary(sf) library(mapview) d \u003c- data.frame( place = c(\"London\", \"Paris\", \"Madrid\", \"Rome\"), long = c(-0.118092, 2.349014, -3.703339, 12.496366), lat = c(51.509865, 48.864716, 40.416729, 41.902782), value = c(200, 300, 400, 500) ) class(d)\rdsf \u003c- st_as_sf(d, coords = c(\"long\", \"lat\")) st_crs(dsf) \u003c- 4326 class(dsf)\rprint(dsf)\rSimple feature collection with 4 features and 2 fields Geometry type: POINT Dimension: XY Bounding box: xmin: -3.703339 ymin: 40.41673 xmax: 12.49637 ymax: 51.50986 Geodetic CRS: WGS 84 place value geometry 1 London 200 POINT (-0.118092 51.50986) 2 Paris 300 POINT (2.349014 48.86472) 3 Madrid 400 POINT (-3.703339 40.41673) 4 Rome 500 POINT (12.49637 41.90278) plot(dsf[0]) plot(dsf[1])\rlibrary(sf) library(ggplot2) # Map with divisions (sf object) map \u003c- read_sf(system.file(\"shape/nc.shp\", package = \"sf\")) # Points over map (simple feature geometry list-column sfc) points \u003c- st_sample(map, size = 100) # 生成 100 个随机点 # Map of points within polygons ggplot() + geom_sf(data = map) + geom_sf(data = points) # Intersection (first argument map, then points) inter \u003c- st_intersects(map, points) # Add point count to each polygon map$count \u003c- lengths(inter) # Map of number of points within polygons ggplot(map) + geom_sf(aes(fill = count))\rWarning message in st_poly_sample(x, size = size, ..., type = type, by_polygon = by_polygon, : \"coordinate ranges not computed along great circles; install package lwgeom to get rid of this warning\" Given a sf object with points and a sf object with polygons, we can also use the st_intersects() function to obtain the polygon each of the points belongs to. For example, Figure 3.6 shows a map with the names of the polygons that contain three points over the map.\nlibrary(sf) library(ggplot2) # Map with divisions (sf object) map \u003c- read_sf(system.file(\"shape/nc.shp\", package = \"sf\")) # Points over map (sf object) points \u003c- st_sample(map, size = 3) %\u003e% st_as_sf() # Intersection (first argument points, then map) inter \u003c- st_intersects(points, map) print(inter) # Adding column areaname with the name of # the areas containing the points points$areaname \u003c- map[unlist(inter), \"NAME\", drop = TRUE] # drop geometry print(points) print(points$areaname)\rSparse geometry binary predicate list of length 3, where the predicate was `intersects' 1: 39 2: 7 3: 68 Simple feature collection with 3 features and 1 field Geometry type: POINT Dimension: XY Bounding box: xmin: -80.91737 ymin: 35.19439 xmax: -76.41681 ymax: 36.4744 Geodetic CRS: NAD27 x areaname 1 POINT (-80.75398 35.87801) Iredell 2 POINT (-76.41681 36.4744) Camden 3 POINT (-80.91737 35.19439) Mecklenburg [1] \"Iredell\" \"Camden\" \"Mecklenburg\" attr(,\"class\") [1] \"character\" # Map ggplot(map) + geom_sf() + geom_sf(data = points) + geom_sf_label(data = map[unlist(inter), ], aes(label = NAME), nudge_y = 0.2)\rWarning message in st_point_on_surface.sfc(sf::st_zm(x)): \"st_point_on_surface may not give correct results for longitude/latitude data\" library(sf) # 创建两个示例数据集：一个多边形和一个点 polys \u003c- st_as_sf(data.frame(id = 1:2, wkt = c(\"POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))\", \"POLYGON((3 0, 3 2, 5 2, 5 0, 3 0))\")), wkt = \"wkt\", crs = 4326) points \u003c- st_as_sf(data.frame(id = 3:4, wkt = c(\"POINT(1 1)\", \"POINT(4 1)\")), wkt = \"wkt\", crs = 4326) # 进行空间连接，将点分配到所在的多边形 joined \u003c- st_join(points, polys) print(joined)\rSimple feature collection with 2 features and 2 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 1 ymin: 1 xmax: 4 ymax: 1 Geodetic CRS: WGS 84 id.x id.y wkt 1 3 1 POINT (1 1) 2 4 2 POINT (4 1) library(terra) pathraster \u003c- system.file(\"ex/elev.tif\", package = \"terra\") r \u003c- rast(pathraster) plot(r)\rlibrary(sf) # 创建一个表示某个地点的点 point \u003c- st_point(c(1, 1)) %\u003e% st_sfc(crs = 4326) %\u003e% st_sf() # %\u003e% 是 管道操作符，用于简化代码的写法 # 来自 magrittr 包（dplyr 包也包括这个操作符） # 它允许你将一个表达式的结果传递给下一个函数，避免嵌套多个函数调用，提高代码的可读性。 # 创建一个围绕这个点的缓冲区，半径为1单位 buffered \u003c- st_buffer(point, dist = 1) plot(buffered, main = \"Buffer around point\")\rlibrary(sf) # 创建多边形 (城市边界) polys \u003c- st_as_sf(data.frame( city = c(\"CityA\", \"CityB\"), geometry = st_sfc( st_polygon(list(rbind(c(0, 0), c(0, 3), c(3, 3), c(3, 0), c(0, 0)))), st_polygon(list(rbind(c(3, 0), c(3, 3), c(6, 3), c(6, 0), c(3, 0)))) ) )) # 创建点 (学校位置) points \u003c- st_as_sf(data.frame( school = c(\"School1\", \"School2\"), geometry = st_sfc(st_point(c(1, 1)), st_point(c(4, 1))) )) # 左连接：将每个学校连接到所在的城市 left_join \u003c- st_join(points, polys, left = TRUE) print(left_join)\rSimple feature collection with 2 features and 2 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 1 ymin: 1 xmax: 4 ymax: 1 CRS: NA school city geometry 1 School1 CityA POINT (1 1) 2 School2 CityB POINT (4 1) # 右连接：保留所有的城市（多边形），即使其中没有学校 right_join \u003c- st_join(polys, points, left = FALSE) print(right_join)\rSimple feature collection with 2 features and 2 fields Geometry type: POLYGON Dimension: XY Bounding box: xmin: 0 ymin: 0 xmax: 6 ymax: 3 CRS: NA city school geometry 1 CityA School1 POLYGON ((0 0, 0 3, 3 3, 3 ... 2 CityB School2 POLYGON ((3 0, 3 3, 6 3, 6 ... # 内连接：仅保留点与多边形有交集的部分 inner_join \u003c- st_join(points, polys, left = FALSE) print(inner_join)\rSimple feature collection with 2 features and 2 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 1 ymin: 1 xmax: 4 ymax: 1 CRS: NA school city geometry 1 School1 CityA POINT (1 1) 2 School2 CityB POINT (4 1) # 创建线 (河流) river \u003c- st_as_sf(data.frame(name = \"River\", geometry = st_sfc(st_linestring(rbind(c(0,0), c(5,5)))))) # 创建点 (学校) points \u003c- st_as_sf(data.frame(school = c(\"School1\", \"School2\", \"School3\"), geometry = st_sfc(st_point(c(1,1)), st_point(c(4,1)), st_point(c(6,6))))) # 为河流创建缓冲区 (例如，1单位范围内) buffered_river \u003c- st_buffer(river, dist = 1) # 查找哪些学校位于河流缓冲区内 buffer_join \u003c- st_join(points, buffered_river, join = st_within) print(buffer_join)\rSimple feature collection with 3 features and 2 fields Geometry type: POINT Dimension: XY Bounding box: xmin: 1 ymin: 1 xmax: 6 ymax: 6 CRS: NA school name geometry 1 School1 River POINT (1 1) 2 School2 \u003cNA\u003e POINT (4 1) 3 School3 \u003cNA\u003e POINT (6 6) 左连接（left = TRUE）：保留第一个数据集的所有几何体。 右连接（left = FALSE）：保留第二个数据集的所有几何体。 内连接：仅保留相交的几何体。\nlibrary(terra) pathraster \u003c- system.file(\"ex/elev.tif\", package = \"terra\") r \u003c- rast(pathraster) plot(r)\r# values(r) # 可能会存在很多的NA值\rr \u003c- rast(ncol = 10, nrow = 10, xmin = -150, xmax = -80, ymin = 20, ymax = 60) r\rnrow(r) # number of rows ncol(r) # number of columns dim(r) # dimension ncell(r) # number of cells\rvalues(r) \u003c- 1:ncell(r)\rr2 \u003c- r * r s \u003c- c(r, r2)\rplot(s[[2]]) # layer 2\rr 和 r2 是两个单层栅格对象，它们是 SpatRaster 类型。 c(r, r2) 将 r 和 r2 组合为一个具有两层的栅格堆栈，每一层是一个栅格对象。这里的 c() 并不是将栅格按列链接，而是将它们组合成多层栅格对象。 结果 s 是一个多层栅格（SpatRaster）对象，每一层保留原栅格的行列结构。 在 terra 包中，c() 函数并不是列链接的意思，而是用于将多个栅格组合成一个多层栅格堆栈。 r 作为栅格对象的行列表示它们的栅格网格结构，而不是向量或数据框中的行链接。 plot(min(s)) plot(r + r + 10) plot(round(r)) plot(r == 1)\rpathshp \u003c- system.file(\"ex/lux.shp\", package = \"terra\") v \u003c- vect(pathshp) v # dimensions：数据包含 12 个几何对象（多边形）和 # 6 个属性字段（如 ID_1, NAME_1, AREA, POP）。\r# Longitude and latitude values long \u003c- c(-0.118092, 2.349014, -3.703339, 12.496366) lat \u003c- c(51.509865, 48.864716, 40.416729, 41.902782) longlat \u003c- cbind(long, lat) # CRS crspoints \u003c- \"+proj=longlat +datum=WGS84\" # Attributes for points d \u003c- data.frame( place = c(\"London\", \"Paris\", \"Madrid\", \"Rome\"), value = c(200, 300, 400, 500)) # SpatVector object pts \u003c- vect(longlat, atts = d, crs = crspoints) pts plot(pts) geometries \u003c- geom(pts) print(geometries) attributes \u003c- values(pts) print(attributes)\rgeom part x y hole [1,] 1 1 -0.118092 51.50986 0 [2,] 2 1 2.349014 48.86472 0 [3,] 3 1 -3.703339 40.41673 0 [4,] 4 1 12.496366 41.90278 0 place value 1 London 200 2 Paris 300 3 Madrid 400 4 Rome 500 library(terra) r \u003c- geodata::worldclim_country(country = \"Spain\", var = \"tavg\", res = 10, path = tempdir()) plot(r)\rdim(r)\rr \u003c- mean(r) dim(r) plot(r) ext(r) r \u003c- terra::mask(r, vect(map)) plot(r)\rWarning message: \"[mask] CRS do not match\" # Aggregating r \u003c- terra::aggregate(r, fact = 20, fun = \"mean\", na.rm = TRUE) # fact = 20：表示将栅格分辨率减少 20 倍， # 即每 20x20 的像元块被聚合为一个新的像元。 # fun = \"mean\"：在聚合过程中，使用平均值作为新的像元值。 # na.rm = TRUE 是一个参数，它的作用是忽略缺失值 (NA) # 在计算栅格数据的聚合时不将 NA 值计入计算 plot(r)\rlibrary(terra) # Raster (SpatRaster) r \u003c- rast(system.file(\"ex/elev.tif\", package = \"terra\")) # Polygons (SpatVector) v \u003c- vect(system.file(\"ex/lux.shp\", package = \"terra\")) plot(r) plot(v)\rif (FALSE) { # 这是多行注释 # 使用 if (FALSE) 包围的代码块不会被执行 z \u003c- 30 print(z) } points \u003c- crds(centroids(v)) # 这行代码的作用是计算矢量对象 v 中几何体的质心（centroid），并提取它们的坐标 plot(r) plot(v, add = TRUE) # add = TRUE 表示在已有的图形上添加新的图层 points(points) # 这行代码在已经绘制好的栅格图和矢量图上添加质心点\rpoints\r# data frame with the coordinates points \u003c- as.data.frame(points) points valuesatpoints \u003c- extract(r, points) cbind(points, valuesatpoints)\r# Extracted raster cells within each polygon head(extract(r, v, na.rm = TRUE))\r# Extracted raster cells and percentage of area # covered within each polygon head(extract(r, v, na.rm = TRUE, weights = TRUE))\r# Average raster values by polygon v$avg \u003c- extract(r, v, mean, na.rm = TRUE)$elevation # Area-weighted average raster values by polygon (weights = TRUE) v$weightedavg \u003c- extract(r, v, mean, na.rm = TRUE, weights = TRUE)$elevation\rprint(v)\rclass : SpatVector geometry : polygons dimensions : 1, 0 (geometries, attributes) extent : 2, 8, 2, 8 (xmin, xmax, ymin, ymax) coord. ref. : library(ggplot2) library(tidyterra) # Plot average raster values within polygons ggplot(data = v) + geom_spatvector(aes(fill = avg)) + scale_fill_terrain_c() # Plot area-weighted average raster values within polygons ggplot(data = v) + geom_spatvector(aes(fill = weightedavg)) + scale_fill_terrain_c()\rlibrary(terra) # 创建一个示例栅格数据 SpatRaster r \u003c- rast(ncol = 10, nrow = 10, xmin = 0, xmax = 10, ymin = 0, ymax = 10) values(r) \u003c- runif(ncell(r), min = 15, max = 25) # 随机填充温度值 # 创建一个示例多边形 SpatVector v \u003c- vect(cbind(c(2, 4, 6, 8), c(2, 4, 6, 8)), type = \"polygons\") # 提取多边形内的像元值，并计算平均温度（默认仅提取中心点被覆盖的像元） extracted_values \u003c- extract(r, v, fun = mean) head(extracted_values)"},"title":"Basic"}}